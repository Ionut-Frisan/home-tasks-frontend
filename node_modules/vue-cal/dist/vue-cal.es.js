var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
/**
  * vue-cal v4.3.4
  * (c) 2022 Antoni Andre <antoniandre.web@gmail.com>
  * @license MIT
  */
import { openBlock as e, createElementBlock as t, Fragment as s, renderList as i, normalizeClass as n, normalizeStyle as a, createVNode as l, Transition as r, withCtx as o, createElementVNode as d, renderSlot as u, toDisplayString as h, createCommentVNode as c, createTextVNode as v, resolveComponent as p, createBlock as m, resolveDynamicComponent as w, createSlots as y, withKeys as D, withModifiers as g, TransitionGroup as f, normalizeProps as _, mergeProps as b } from "vue";
let k, M, T, E, C = {}, S = {};
class O {
  constructor(e2) {
    __publicField(this, "_vuecal", null);
    __publicField(this, "selectCell", (e2 = false, t2, s2) => {
      this._vuecal.$emit("cell-click", s2 ? { date: t2, split: s2 } : t2), this._vuecal.clickToNavigate || e2 ? this._vuecal.switchToNarrowerView() : this._vuecal.dblclickToNavigate && "ontouchstart" in window && (this._vuecal.domEvents.dblTapACell.taps++, setTimeout(() => this._vuecal.domEvents.dblTapACell.taps = 0, this._vuecal.domEvents.dblTapACell.timeout), this._vuecal.domEvents.dblTapACell.taps >= 2 && (this._vuecal.domEvents.dblTapACell.taps = 0, this._vuecal.switchToNarrowerView(), this._vuecal.$emit("cell-dblclick", s2 ? { date: t2, split: s2 } : t2)));
    });
    __publicField(this, "keyPressEnterCell", (e2, t2) => {
      this._vuecal.$emit("cell-keypress-enter", t2 ? { date: e2, split: t2 } : e2), this._vuecal.switchToNarrowerView();
    });
    __publicField(this, "getPosition", (e2) => {
      const { left: t2, top: s2 } = this._vuecal.cellsEl.getBoundingClientRect(), { clientX: i2, clientY: n2 } = "ontouchstart" in window && e2.touches ? e2.touches[0] : e2;
      return { x: i2 - t2, y: n2 - s2 };
    });
    __publicField(this, "minutesAtCursor", (e2) => {
      let t2 = 0, s2 = { x: 0, y: 0 };
      const { timeStep: i2, timeCellHeight: n2, timeFrom: a2 } = this._vuecal.$props;
      return "number" == typeof e2 ? t2 = e2 : "object" == typeof e2 && (s2 = this.getPosition(e2), t2 = Math.round(s2.y * i2 / parseInt(n2) + a2)), { minutes: Math.max(Math.min(t2, 1440), 0), cursorCoords: s2 };
    });
    this._vuecal = e2;
  }
}
let $, x, H;
class W {
  constructor(e2, t2) {
    __publicField(this, "_vuecal", null);
    __publicField(this, "eventDefaults", { _eid: null, start: "", startTimeMinutes: 0, end: "", endTimeMinutes: 0, title: "", content: "", background: false, allDay: false, segments: null, repeat: null, daysCount: 1, deletable: true, deleting: false, titleEditable: true, resizable: true, resizing: false, draggable: true, dragging: false, draggingStatic: false, focused: false, class: "" });
    this._vuecal = e2, $ = t2;
  }
  createAnEvent(e2, t2, s2) {
    if ("string" == typeof e2 && (e2 = $.stringToDate(e2)), !(e2 instanceof Date))
      return false;
    const i2 = $.dateToMinutes(e2), n2 = i2 + (t2 = 1 * t2 || 120), a2 = $.addMinutes(new Date(e2), t2);
    s2.end && ("string" == typeof s2.end && (s2.end = $.stringToDate(s2.end)), s2.endTimeMinutes = $.dateToMinutes(s2.end));
    const l2 = { ...this.eventDefaults, _eid: `${this._vuecal._.uid}_${this._vuecal.eventIdIncrement++}`, start: e2, startTimeMinutes: i2, end: a2, endTimeMinutes: n2, segments: null, ...s2 };
    return "function" != typeof this._vuecal.onEventCreate || this._vuecal.onEventCreate(l2, () => this.deleteAnEvent(l2)) ? (l2.startDateF !== l2.endDateF && (l2.daysCount = $.countDays(l2.start, l2.end)), this._vuecal.mutableEvents.push(l2), this._vuecal.addEventsToView([l2]), this._vuecal.emitWithEvent("event-create", l2), this._vuecal.$emit("event-change", { event: this._vuecal.cleanupEvent(l2), originalEvent: null }), l2) : void 0;
  }
  addEventSegment(e2) {
    e2.segments || (e2.segments = {}, e2.segments[$.formatDateLite(e2.start)] = { start: e2.start, startTimeMinutes: e2.startTimeMinutes, endTimeMinutes: 1440, isFirstDay: true, isLastDay: false });
    const t2 = e2.segments[$.formatDateLite(e2.end)];
    t2 && (t2.isLastDay = false, t2.endTimeMinutes = 1440);
    const s2 = $.addDays(e2.end, 1), i2 = $.formatDateLite(s2);
    return s2.setHours(0, 0, 0, 0), e2.segments[i2] = { start: s2, startTimeMinutes: 0, endTimeMinutes: e2.endTimeMinutes, isFirstDay: false, isLastDay: true }, e2.end = $.addMinutes(s2, e2.endTimeMinutes), e2.daysCount = Object.keys(e2.segments).length, i2;
  }
  removeEventSegment(e2) {
    let t2 = Object.keys(e2.segments).length;
    if (t2 <= 1)
      return $.formatDateLite(e2.end);
    delete e2.segments[$.formatDateLite(e2.end)], t2--;
    const s2 = $.subtractDays(e2.end, 1), i2 = $.formatDateLite(s2), n2 = e2.segments[i2];
    return t2 ? n2 && (n2.isLastDay = true, n2.endTimeMinutes = e2.endTimeMinutes) : e2.segments = null, e2.daysCount = t2 || 1, e2.end = s2, i2;
  }
  createEventSegments(e2, t2, s2) {
    const i2 = t2.getTime(), n2 = s2.getTime();
    let a2, l2, r2, o2 = e2.start.getTime(), d2 = e2.end.getTime(), u2 = false;
    for (e2.end.getHours() || e2.end.getMinutes() || (d2 -= 1e3), e2.segments = {}, e2.repeat ? (a2 = i2, l2 = Math.min(n2, e2.repeat.until ? $.stringToDate(e2.repeat.until).getTime() : n2)) : (a2 = Math.max(i2, o2), l2 = Math.min(n2, d2)); a2 <= l2; ) {
      let t3 = false;
      const s3 = $.addDays(new Date(a2), 1).setHours(0, 0, 0, 0);
      let i3, n3, h2, c2;
      if (e2.repeat) {
        const s4 = new Date(a2), l3 = $.formatDateLite(s4);
        (u2 || e2.occurrences && e2.occurrences[l3]) && (u2 || (o2 = e2.occurrences[l3].start, r2 = new Date(o2).setHours(0, 0, 0, 0), d2 = e2.occurrences[l3].end), u2 = true, t3 = true), i3 = a2 === r2, n3 = l3 === $.formatDateLite(new Date(d2)), h2 = new Date(i3 ? o2 : a2), c2 = $.formatDateLite(h2), n3 && (u2 = false);
      } else
        t3 = true, i3 = a2 === o2, n3 = l2 === d2 && s3 > l2, h2 = i3 ? e2.start : new Date(a2), c2 = $.formatDateLite(i3 ? e2.start : h2);
      t3 && (e2.segments[c2] = { start: h2, startTimeMinutes: i3 ? e2.startTimeMinutes : 0, endTimeMinutes: n3 ? e2.endTimeMinutes : 1440, isFirstDay: i3, isLastDay: n3 }), a2 = s3;
    }
    return e2;
  }
  deleteAnEvent(e2) {
    this._vuecal.emitWithEvent("event-delete", e2), this._vuecal.mutableEvents = this._vuecal.mutableEvents.filter((t2) => t2._eid !== e2._eid), this._vuecal.view.events = this._vuecal.view.events.filter((t2) => t2._eid !== e2._eid);
  }
  checkCellOverlappingEvents(e2, t2) {
    H = e2.slice(0), x = {}, e2.forEach((e3) => {
      H.shift(), x[e3._eid] || (x[e3._eid] = { overlaps: [], start: e3.start, position: 0 }), x[e3._eid].position = 0, H.forEach((s3) => {
        x[s3._eid] || (x[s3._eid] = { overlaps: [], start: s3.start, position: 0 });
        const i2 = this.eventInRange(s3, e3.start, e3.end), n2 = t2.overlapsPerTimeStep ? $.datesInSameTimeStep(e3.start, s3.start, t2.timeStep) : 1;
        if (e3.background || e3.allDay || s3.background || s3.allDay || !i2 || !n2) {
          let t3, i3;
          (t3 = (x[e3._eid] || { overlaps: [] }).overlaps.indexOf(s3._eid)) > -1 && x[e3._eid].overlaps.splice(t3, 1), (i3 = (x[s3._eid] || { overlaps: [] }).overlaps.indexOf(e3._eid)) > -1 && x[s3._eid].overlaps.splice(i3, 1), x[s3._eid].position--;
        } else
          x[e3._eid].overlaps.push(s3._eid), x[e3._eid].overlaps = [...new Set(x[e3._eid].overlaps)], x[s3._eid].overlaps.push(e3._eid), x[s3._eid].overlaps = [...new Set(x[s3._eid].overlaps)], x[s3._eid].position++;
      });
    });
    let s2 = 0;
    for (const e3 in x) {
      const t3 = x[e3], i2 = t3.overlaps.map((e4) => ({ id: e4, start: x[e4].start }));
      i2.push({ id: e3, start: t3.start }), i2.sort((e4, t4) => e4.start < t4.start ? -1 : e4.start > t4.start ? 1 : e4.id > t4.id ? -1 : 1), t3.position = i2.findIndex((t4) => t4.id === e3), s2 = Math.max(this.getOverlapsStreak(t3, x), s2);
    }
    return [x, s2];
  }
  getOverlapsStreak(e2, t2 = {}) {
    let s2 = e2.overlaps.length + 1, i2 = [];
    return e2.overlaps.forEach((s3) => {
      if (!i2.includes(s3)) {
        e2.overlaps.filter((e3) => e3 !== s3).forEach((e3) => {
          t2[e3].overlaps.includes(s3) || i2.push(e3);
        });
      }
    }), i2 = [...new Set(i2)], s2 -= i2.length, s2;
  }
  eventInRange(e2, t2, s2) {
    if (e2.allDay || !this._vuecal.time) {
      const i3 = new Date(e2.start).setHours(0, 0, 0, 0);
      return new Date(e2.end).setHours(23, 59, 0, 0) >= new Date(t2).setHours(0, 0, 0, 0) && i3 <= new Date(s2).setHours(0, 0, 0, 0);
    }
    const i2 = e2.start.getTime(), n2 = e2.end.getTime();
    return i2 < s2.getTime() && n2 > t2.getTime();
  }
}
const j = { class: "vuecal__flex vuecal__weekdays-headings" }, A = ["onClick"], V = { class: "vuecal__flex weekday-label", grow: "" }, Y = { class: "full" }, L = { class: "small" }, F = { class: "xsmall" }, B = { key: 0 }, N = { key: 0, class: "vuecal__flex vuecal__split-days-headers", grow: "" };
var z = (e2, t2) => {
  const s2 = e2.__vccOpts || e2;
  for (const [e3, i2] of t2)
    s2[e3] = i2;
  return s2;
};
var I = z({ inject: ["vuecal", "utils", "view"], props: { transitionDirection: { type: String, default: "right" }, weekDays: { type: Array, default: () => [] }, switchToNarrowerView: { type: Function, default: () => {
} } }, methods: { selectCell(e2, t2) {
  e2.getTime() !== this.view.selectedDate.getTime() && (this.view.selectedDate = e2), this.utils.cell.selectCell(false, e2, t2);
}, cleanupHeading: (e2) => ({ label: e2.full, date: e2.date, ...e2.today ? { today: e2.today } : {} }) }, computed: { headings() {
  if (!["month", "week"].includes(this.view.id))
    return [];
  let e2 = false;
  return this.weekDays.map((t2, s2) => {
    const i2 = this.utils.date.addDays(this.view.startDate, s2);
    return { hide: t2.hide, full: t2.label, small: t2.short || t2.label.substr(0, 3), xsmall: t2.short || t2.label.substr(0, 1), ..."week" === this.view.id ? { dayOfMonth: i2.getDate(), date: i2, today: !e2 && this.utils.date.isToday(i2) && !e2++ } : {} };
  });
}, cellWidth() {
  return 100 / (7 - this.weekDays.reduce((e2, t2) => e2 + t2.hide, 0));
}, weekdayCellStyles() {
  return { ...this.vuecal.hideWeekdays.length ? { width: `${this.cellWidth}%` } : {} };
}, cellHeadingsClickable() {
  return "week" === this.view.id && (this.vuecal.clickToNavigate || this.vuecal.dblclickToNavigate);
} } }, [["render", function(p2, m2, w2, y2, D2, g2) {
  return e(), t("div", j, [(e(true), t(s, null, i(g2.headings, (y3, D3) => (e(), t(s, { key: D3 }, [y3.hide ? c("", true) : (e(), t("div", { key: 0, class: n(["vuecal__flex vuecal__heading", { today: y3.today, clickable: g2.cellHeadingsClickable }]), style: a(g2.weekdayCellStyles), onClick: (e2) => "week" === g2.view.id && g2.selectCell(y3.date, e2), onDblclick: m2[0] || (m2[0] = (e2) => "week" === g2.view.id && g2.vuecal.dblclickToNavigate && w2.switchToNarrowerView()) }, [l(r, { name: `slide-fade--${w2.transitionDirection}`, appear: g2.vuecal.transitions }, { default: o(() => [(e(), t("div", { class: "vuecal__flex", column: "", key: !!g2.vuecal.transitions && `${D3}-${y3.dayOfMonth}` }, [d("div", V, [u(p2.$slots, "weekday-heading", { heading: g2.cleanupHeading(y3), view: g2.view }, () => [d("span", Y, h(y3.full), 1), d("span", L, h(y3.small), 1), d("span", F, h(y3.xsmall), 1), y3.dayOfMonth ? (e(), t("span", B, "\xA0" + h(y3.dayOfMonth), 1)) : c("", true)])]), g2.vuecal.hasSplits && g2.vuecal.stickySplitLabels ? (e(), t("div", N, [(e(true), t(s, null, i(g2.vuecal.daySplits, (s2, i2) => (e(), t("div", { class: n(["day-split-header", s2.class || false]), key: i2 }, [u(p2.$slots, "split-label", { split: s2, view: g2.view }, () => [v(h(s2.label), 1)])], 2))), 128))])) : c("", true)]))]), _: 2 }, 1032, ["name", "appear"])], 46, A))], 64))), 128))]);
}]]);
const P = { class: "vuecal__header" }, U = { key: 0, class: "vuecal__flex vuecal__menu", role: "tablist", "aria-label": "Calendar views navigation" }, R = ["onDragenter", "onDragleave", "onClick", "aria-label"], q = { key: 1, class: "vuecal__title-bar" }, K = ["aria-label"], X = { class: "vuecal__flex vuecal__title", grow: "" }, G = ["aria-label"], Z = { key: 0, class: "vuecal__flex vuecal__split-days-headers" };
var J = z({ inject: ["vuecal", "previous", "next", "switchView", "updateSelectedDate", "modules", "view"], components: { WeekdaysHeadings: I }, props: { options: { type: Object, default: () => ({}) }, editEvents: { type: Object, required: true }, hasSplits: { type: [Boolean, Number], default: false }, daySplits: { type: Array, default: () => [] }, viewProps: { type: Object, default: () => ({}) }, weekDays: { type: Array, default: () => [] }, switchToNarrowerView: { type: Function, default: () => {
} } }, data: () => ({ highlightedControl: null }), methods: { goToToday() {
  this.updateSelectedDate(new Date(new Date().setHours(0, 0, 0, 0)));
}, switchToBroaderView() {
  this.transitionDirection = "left", this.broaderView && this.switchView(this.broaderView);
} }, computed: { transitionDirection: { get() {
  return this.vuecal.transitionDirection;
}, set(e2) {
  this.vuecal.transitionDirection = e2;
} }, broaderView() {
  const { enabledViews: e2 } = this.vuecal;
  return e2[e2.indexOf(this.view.id) - 1];
}, showDaySplits() {
  return "day" === this.view.id && this.hasSplits && this.options.stickySplitLabels && !this.options.minSplitWidth;
}, dnd() {
  return this.modules.dnd;
} } }, [["render", function(a2, D2, g2, f2, _2, b2) {
  const k2 = p("weekdays-headings");
  return e(), t("div", P, [g2.options.hideViewSelector ? c("", true) : (e(), t("div", U, [(e(true), t(s, null, i(g2.viewProps.views, (i2, l2) => (e(), t(s, { key: l2 }, [i2.enabled ? (e(), t("button", { key: 0, class: n(["vuecal__view-btn", { "vuecal__view-btn--active": b2.view.id === l2, "vuecal__view-btn--highlighted": a2.highlightedControl === l2 }]), type: "button", onDragenter: (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragEnter(e2, l2, a2.$data), onDragleave: (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragLeave(e2, l2, a2.$data), onClick: (e2) => b2.switchView(l2, null, true), "aria-label": `${i2.label} view` }, h(i2.label), 43, R)) : c("", true)], 64))), 128))])), g2.options.hideTitleBar ? c("", true) : (e(), t("div", q, [d("button", { class: n(["vuecal__arrow vuecal__arrow--prev", { "vuecal__arrow--highlighted": "previous" === a2.highlightedControl }]), type: "button", onClick: D2[0] || (D2[0] = (...e2) => b2.previous && b2.previous(...e2)), onDragenter: D2[1] || (D2[1] = (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragEnter(e2, "previous", a2.$data)), onDragleave: D2[2] || (D2[2] = (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragLeave(e2, "previous", a2.$data)), "aria-label": `Previous ${b2.view.id}` }, [u(a2.$slots, "arrow-prev")], 42, K), d("div", X, [l(r, { name: g2.options.transitions ? `slide-fade--${b2.transitionDirection}` : "" }, { default: o(() => [(e(), m(w(b2.broaderView ? "button" : "span"), { type: !!b2.broaderView && "button", key: `${b2.view.id}${b2.view.startDate.toString()}`, onClick: D2[3] || (D2[3] = (e2) => !!b2.broaderView && b2.switchToBroaderView()), "aria-label": !!b2.broaderView && `Go to ${b2.broaderView} view` }, { default: o(() => [u(a2.$slots, "title")]), _: 3 }, 8, ["type", "aria-label"]))]), _: 3 }, 8, ["name"])]), g2.options.todayButton ? (e(), t("button", { key: 0, class: n(["vuecal__today-btn", { "vuecal__today-btn--highlighted": "today" === a2.highlightedControl }]), type: "button", onClick: D2[4] || (D2[4] = (...e2) => b2.goToToday && b2.goToToday(...e2)), onDragenter: D2[5] || (D2[5] = (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragEnter(e2, "today", a2.$data)), onDragleave: D2[6] || (D2[6] = (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragLeave(e2, "today", a2.$data)), "aria-label": "Today" }, [u(a2.$slots, "today-button")], 34)) : c("", true), d("button", { class: n(["vuecal__arrow vuecal__arrow--next", { "vuecal__arrow--highlighted": "next" === a2.highlightedControl }]), type: "button", onClick: D2[7] || (D2[7] = (...e2) => b2.next && b2.next(...e2)), onDragenter: D2[8] || (D2[8] = (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragEnter(e2, "next", a2.$data)), onDragleave: D2[9] || (D2[9] = (e2) => g2.editEvents.drag && b2.dnd && b2.dnd.viewSelectorDragLeave(e2, "next", a2.$data)), "aria-label": `Next ${b2.view.id}` }, [u(a2.$slots, "arrow-next")], 42, G)])), g2.viewProps.weekDaysInHeader ? (e(), m(k2, { key: 2, "week-days": g2.weekDays, "transition-direction": b2.transitionDirection, "switch-to-narrower-view": g2.switchToNarrowerView }, y({ _: 2 }, [a2.$slots["weekday-heading"] ? { name: "weekday-heading", fn: o(({ heading: e2, view: t2 }) => [u(a2.$slots, "weekday-heading", { heading: e2, view: t2 })]) } : void 0, a2.$slots["split-label"] ? { name: "split-label", fn: o(({ split: e2 }) => [u(a2.$slots, "split-label", { split: e2, view: b2.view })]) } : void 0]), 1032, ["week-days", "transition-direction", "switch-to-narrower-view"])) : c("", true), l(r, { name: `slide-fade--${b2.transitionDirection}` }, { default: o(() => [b2.showDaySplits ? (e(), t("div", Z, [(e(true), t(s, null, i(g2.daySplits, (s2, i2) => (e(), t("div", { class: n(["day-split-header", s2.class || false]), key: i2 }, [u(a2.$slots, "split-label", { split: s2, view: b2.view.id }, () => [v(h(s2.label), 1)])], 2))), 128))])) : c("", true)]), _: 3 }, 8, ["name"])]);
}]]);
const Q = ["draggable"];
const ee = { inject: ["vuecal", "utils", "modules", "view", "domEvents", "editEvents"], props: { cellFormattedDate: { type: String, default: "" }, event: { type: Object, default: () => ({}) }, cellEvents: { type: Array, default: () => [] }, overlaps: { type: Array, default: () => [] }, eventPosition: { type: Number, default: 0 }, overlapsStreak: { type: Number, default: 0 }, allDay: { type: Boolean, default: false } }, data: () => ({ touch: { dragThreshold: 30, startX: 0, startY: 0, dragged: false } }), methods: { onMouseDown(e2, t2 = false) {
  if ("ontouchstart" in window && !t2)
    return false;
  const { clickHoldAnEvent: s2, focusAnEvent: i2, resizeAnEvent: n2, dragAnEvent: a2 } = this.domEvents;
  if (i2._eid === this.event._eid && s2._eid === this.event._eid)
    return true;
  this.focusEvent(), s2._eid = null, this.vuecal.editEvents.delete && this.event.deletable && (s2.timeoutId = setTimeout(() => {
    n2._eid || a2._eid || (s2._eid = this.event._eid, this.event.deleting = true);
  }, s2.timeout));
}, onMouseUp(e2) {
  this.domEvents.focusAnEvent._eid !== this.event._eid || this.touch.dragged || (this.domEvents.focusAnEvent.mousedUp = true), this.touch.dragged = false;
}, onMouseEnter(e2) {
  e2.preventDefault(), this.vuecal.emitWithEvent("event-mouse-enter", this.event);
}, onMouseLeave(e2) {
  e2.preventDefault(), this.vuecal.emitWithEvent("event-mouse-leave", this.event);
}, onTouchMove(e2) {
  if ("function" != typeof this.vuecal.onEventClick)
    return;
  const { clientX: t2, clientY: s2 } = e2.touches[0], { startX: i2, startY: n2, dragThreshold: a2 } = this.touch;
  (Math.abs(t2 - i2) > a2 || Math.abs(s2 - n2) > a2) && (this.touch.dragged = true);
}, onTouchStart(e2) {
  this.touch.startX = e2.touches[0].clientX, this.touch.startY = e2.touches[0].clientY, this.onMouseDown(e2, true);
}, onEnterKeypress(e2) {
  if ("function" == typeof this.vuecal.onEventClick)
    return this.vuecal.onEventClick(this.event, e2);
}, onDblClick(e2) {
  if ("function" == typeof this.vuecal.onEventDblclick)
    return this.vuecal.onEventDblclick(this.event, e2);
}, onDragStart(e2) {
  this.dnd && this.dnd.eventDragStart(e2, this.event);
}, onDragEnd() {
  this.dnd && this.dnd.eventDragEnd(this.event);
}, onResizeHandleMouseDown() {
  this.focusEvent(), this.domEvents.dragAnEvent._eid = null, this.domEvents.resizeAnEvent = Object.assign(this.domEvents.resizeAnEvent, { _eid: this.event._eid, start: (this.segment || this.event).start, split: this.event.split || null, segment: !!this.segment && this.utils.date.formatDateLite(this.segment.start), originalEnd: new Date((this.segment || this.event).end), originalEndTimeMinutes: this.event.endTimeMinutes }), this.event.resizing = true;
}, deleteEvent(e2 = false) {
  if ("ontouchstart" in window && !e2)
    return false;
  this.utils.event.deleteAnEvent(this.event);
}, touchDeleteEvent(e2) {
  this.deleteEvent(true);
}, cancelDeleteEvent() {
  this.event.deleting = false;
}, focusEvent() {
  const { focusAnEvent: e2 } = this.domEvents, t2 = e2._eid;
  if (t2 !== this.event._eid) {
    if (t2) {
      const e3 = this.view.events.find((e4) => e4._eid === t2);
      e3 && (e3.focused = false);
    }
    this.vuecal.cancelDelete(), this.vuecal.emitWithEvent("event-focus", this.event), e2._eid = this.event._eid, this.event.focused = true;
  }
} }, computed: { eventDimensions() {
  const { startTimeMinutes: e2, endTimeMinutes: t2 } = this.segment || this.event;
  let s2 = e2 - this.vuecal.timeFrom;
  const i2 = Math.max(Math.round(s2 * this.vuecal.timeCellHeight / this.vuecal.timeStep), 0);
  s2 = Math.min(t2, this.vuecal.timeTo) - this.vuecal.timeFrom;
  const n2 = Math.round(s2 * this.vuecal.timeCellHeight / this.vuecal.timeStep);
  return { top: i2, height: Math.max(n2 - i2, 5) };
}, eventStyles() {
  if (this.event.allDay || !this.vuecal.time || !this.event.endTimeMinutes || "month" === this.view.id || this.allDay)
    return {};
  let e2 = 100 / Math.min(this.overlaps.length + 1, this.overlapsStreak), t2 = 100 / (this.overlaps.length + 1) * this.eventPosition;
  this.vuecal.minEventWidth && e2 < this.vuecal.minEventWidth && (e2 = this.vuecal.minEventWidth, t2 = (100 - this.vuecal.minEventWidth) / this.overlaps.length * this.eventPosition);
  const { top: s2, height: i2 } = this.eventDimensions;
  return { top: `${s2}px`, height: `${i2}px`, width: `${e2}%`, left: this.event.left && `${this.event.left}px` || `${t2}%` };
}, eventClasses() {
  const { isFirstDay: e2, isLastDay: t2 } = this.segment || {};
  return { [this.event.class]: !!this.event.class, "vuecal__event--focus": this.event.focused, "vuecal__event--resizing": this.event.resizing, "vuecal__event--background": this.event.background, "vuecal__event--deletable": this.event.deleting, "vuecal__event--all-day": this.event.allDay, "vuecal__event--dragging": !this.event.draggingStatic && this.event.dragging, "vuecal__event--static": this.event.dragging && this.event.draggingStatic, "vuecal__event--multiple-days": !!this.segment, "event-start": this.segment && e2 && !t2, "event-middle": this.segment && !e2 && !t2, "event-end": this.segment && t2 && !e2 };
}, segment() {
  return this.event.segments && this.event.segments[this.cellFormattedDate] || null;
}, draggable() {
  const { draggable: e2, background: t2, daysCount: s2 } = this.event;
  return this.vuecal.editEvents.drag && e2 && !t2 && 1 === s2;
}, resizable() {
  const { editEvents: e2, time: t2 } = this.vuecal;
  return e2.resize && this.event.resizable && t2 && !this.allDay && (!this.segment || this.segment && this.segment.isLastDay) && "month" !== this.view.id;
}, dnd() {
  return this.modules.dnd;
} } };
const te = ["data-split", "aria-label", "onTouchstart", "onMousedown", "onDragover", "onDrop"], se = { key: 1, class: "vuecal__cell-events" }, ie = ["title"];
var ne = z({ inject: ["vuecal", "utils", "modules", "view", "domEvents"], components: { Event: z(ee, [["render", function(s2, i2, l2, r2, o2, d2) {
  return e(), t("div", { class: n(["vuecal__event", d2.eventClasses]), style: a(d2.eventStyles), tabindex: "0", onFocus: i2[4] || (i2[4] = (...e2) => d2.focusEvent && d2.focusEvent(...e2)), onKeypress: i2[5] || (i2[5] = D(g((...e2) => d2.onEnterKeypress && d2.onEnterKeypress(...e2), ["stop"]), ["enter"])), onMouseenter: i2[6] || (i2[6] = (...e2) => d2.onMouseEnter && d2.onMouseEnter(...e2)), onMouseleave: i2[7] || (i2[7] = (...e2) => d2.onMouseLeave && d2.onMouseLeave(...e2)), onTouchstart: i2[8] || (i2[8] = g((...e2) => d2.onTouchStart && d2.onTouchStart(...e2), ["stop"])), onMousedown: i2[9] || (i2[9] = (e2) => d2.onMouseDown(e2)), onMouseup: i2[10] || (i2[10] = (...e2) => d2.onMouseUp && d2.onMouseUp(...e2)), onTouchend: i2[11] || (i2[11] = (...e2) => d2.onMouseUp && d2.onMouseUp(...e2)), onTouchmove: i2[12] || (i2[12] = (...e2) => d2.onTouchMove && d2.onTouchMove(...e2)), onDblclick: i2[13] || (i2[13] = (...e2) => d2.onDblClick && d2.onDblClick(...e2)), draggable: d2.draggable, onDragstart: i2[14] || (i2[14] = (e2) => d2.draggable && d2.onDragStart(e2)), onDragend: i2[15] || (i2[15] = (e2) => d2.draggable && d2.onDragEnd()) }, [d2.vuecal.editEvents.delete && l2.event.deletable ? (e(), t("div", { key: 0, class: "vuecal__event-delete", onClick: i2[0] || (i2[0] = g((...e2) => d2.deleteEvent && d2.deleteEvent(...e2), ["stop"])), onTouchstart: i2[1] || (i2[1] = g((...e2) => d2.touchDeleteEvent && d2.touchDeleteEvent(...e2), ["stop"])) }, h(d2.vuecal.texts.deleteEvent), 33)) : c("", true), u(s2.$slots, "event", { event: l2.event, view: d2.view.id }), d2.resizable ? (e(), t("div", { key: 1, class: "vuecal__event-resize-handle", contenteditable: "false", onMousedown: i2[2] || (i2[2] = g((...e2) => d2.onResizeHandleMouseDown && d2.onResizeHandleMouseDown(...e2), ["stop", "prevent"])), onTouchstart: i2[3] || (i2[3] = g((...e2) => d2.onResizeHandleMouseDown && d2.onResizeHandleMouseDown(...e2), ["stop", "prevent"])) }, null, 32)) : c("", true)], 46, Q);
}]]) }, props: { options: { type: Object, default: () => ({}) }, editEvents: { type: Object, required: true }, data: { type: Object, required: true }, cellSplits: { type: Array, default: () => [] }, minTimestamp: { type: [Number, null], default: null }, maxTimestamp: { type: [Number, null], default: null }, cellWidth: { type: [Number, Boolean], default: false }, allDay: { type: Boolean, default: false } }, data: () => ({ cellOverlaps: {}, cellOverlapsStreak: 1, timeAtCursor: null, highlighted: false, highlightedSplit: null }), methods: { getSplitAtCursor({ target: e2 }) {
  let t2 = e2.classList.contains("vuecal__cell-split") ? e2 : this.vuecal.findAncestor(e2, "vuecal__cell-split");
  return t2 && (t2 = t2.attributes["data-split"].value, parseInt(t2).toString() === t2.toString() && (t2 = parseInt(t2))), t2 || null;
}, splitClasses(e2) {
  return { "vuecal__cell-split": true, "vuecal__cell-split--highlighted": this.highlightedSplit === e2.id, [e2.class]: !!e2.class };
}, checkCellOverlappingEvents() {
  this.options.time && this.eventsCount && !this.splitsCount && (1 === this.eventsCount ? (this.cellOverlaps = [], this.cellOverlapsStreak = 1) : [this.cellOverlaps, this.cellOverlapsStreak] = this.utils.event.checkCellOverlappingEvents(this.events, this.options));
}, isDOMElementAnEvent(e2) {
  return this.vuecal.isDOMElementAnEvent(e2);
}, selectCell(e2, t2 = false) {
  const s2 = this.splitsCount ? this.getSplitAtCursor(e2) : null;
  this.utils.cell.selectCell(t2, this.timeAtCursor, s2), this.timeAtCursor = null;
}, onCellkeyPressEnter(e2) {
  this.isSelected || this.onCellFocus(e2);
  const t2 = this.splitsCount ? this.getSplitAtCursor(e2) : null;
  this.utils.cell.keyPressEnterCell(this.timeAtCursor, t2), this.timeAtCursor = null;
}, onCellFocus(e2) {
  if (!this.isSelected && !this.isDisabled) {
    this.isSelected = this.data.startDate;
    const t2 = this.splitsCount ? this.getSplitAtCursor(e2) : null, s2 = this.timeAtCursor || this.data.startDate;
    this.vuecal.$emit("cell-focus", t2 ? { date: s2, split: t2 } : s2);
  }
}, onCellMouseDown(e2, t2 = null, s2 = false) {
  if ("ontouchstart" in window && !s2)
    return false;
  this.isSelected || this.onCellFocus(e2);
  const { clickHoldACell: i2, focusAnEvent: n2 } = this.domEvents;
  this.domEvents.cancelClickEventCreation = false, i2.eventCreated = false, this.timeAtCursor = new Date(this.data.startDate);
  const { minutes: a2, cursorCoords: { y: l2 } } = this.vuecal.minutesAtCursor(e2);
  this.timeAtCursor.setMinutes(a2);
  const r2 = this.isDOMElementAnEvent(e2.target);
  !r2 && n2._eid && ((this.view.events.find((e3) => e3._eid === n2._eid) || {}).focused = false), this.editEvents.create && !r2 && this.setUpEventCreation(e2, l2);
}, setUpEventCreation(e2, t2) {
  if (this.options.dragToCreateEvent && ["week", "day"].includes(this.view.id)) {
    const { dragCreateAnEvent: s2 } = this.domEvents;
    if (s2.startCursorY = t2, s2.split = this.splitsCount ? this.getSplitAtCursor(e2) : null, s2.start = this.timeAtCursor, this.options.snapToTime) {
      let e3 = 60 * this.timeAtCursor.getHours() + this.timeAtCursor.getMinutes();
      const t3 = e3 + this.options.snapToTime / 2;
      e3 = t3 - t3 % this.options.snapToTime, s2.start.setHours(0, e3, 0, 0);
    }
  } else
    this.options.cellClickHold && ["month", "week", "day"].includes(this.view.id) && this.setUpCellHoldTimer(e2);
}, setUpCellHoldTimer(e2) {
  const { clickHoldACell: t2 } = this.domEvents;
  t2.cellId = `${this.vuecal._.uid}_${this.data.formattedDate}`, t2.split = this.splitsCount ? this.getSplitAtCursor(e2) : null, t2.timeoutId = setTimeout(() => {
    if (t2.cellId && !this.domEvents.cancelClickEventCreation) {
      const { _eid: e3 } = this.utils.event.createAnEvent(this.timeAtCursor, null, t2.split ? { split: t2.split } : {});
      t2.eventCreated = e3;
    }
  }, t2.timeout);
}, onCellTouchStart(e2, t2 = null) {
  this.onCellMouseDown(e2, t2, true);
}, onCellClick(e2) {
  this.isDOMElementAnEvent(e2.target) || this.selectCell(e2);
}, onCellDblClick(e2) {
  const t2 = new Date(this.data.startDate);
  t2.setMinutes(this.vuecal.minutesAtCursor(e2).minutes);
  const s2 = this.splitsCount ? this.getSplitAtCursor(e2) : null;
  this.vuecal.$emit("cell-dblclick", s2 ? { date: t2, split: s2 } : t2), this.options.dblclickToNavigate && this.vuecal.switchToNarrowerView();
}, onCellContextMenu(e2) {
  e2.stopPropagation(), e2.preventDefault();
  const t2 = new Date(this.data.startDate), { cursorCoords: s2, minutes: i2 } = this.vuecal.minutesAtCursor(e2);
  t2.setMinutes(i2);
  const n2 = this.splitsCount ? this.getSplitAtCursor(e2) : null;
  this.vuecal.$emit("cell-contextmenu", { date: t2, ...s2, ...n2 || {}, e: e2 });
} }, computed: { dnd() {
  return this.modules.dnd;
}, nowInMinutes() {
  return this.utils.date.dateToMinutes(this.vuecal.now);
}, isBeforeMinDate() {
  return null !== this.minTimestamp && this.minTimestamp > this.data.endDate.getTime();
}, isAfterMaxDate() {
  return this.maxTimestamp && this.maxTimestamp < this.data.startDate.getTime();
}, isDisabled() {
  const { disableDays: e2 } = this.options, { isYearsOrYearView: t2 } = this.vuecal;
  return !(!e2.length || !e2.includes(this.data.formattedDate) || t2) || (this.isBeforeMinDate || this.isAfterMaxDate);
}, isSelected: { get() {
  let e2 = false;
  const { selectedDate: t2 } = this.view;
  return e2 = "years" === this.view.id ? t2.getFullYear() === this.data.startDate.getFullYear() : "year" === this.view.id ? t2.getFullYear() === this.data.startDate.getFullYear() && t2.getMonth() === this.data.startDate.getMonth() : t2.getTime() === this.data.startDate.getTime(), e2;
}, set(e2) {
  this.view.selectedDate = e2;
} }, isWeekOrDayView() {
  return ["week", "day"].includes(this.view.id);
}, transitionDirection() {
  return this.vuecal.transitionDirection;
}, specialHours() {
  return this.data.specialHours.map((e2) => {
    let { from: t2, to: s2 } = e2;
    return t2 = Math.max(t2, this.options.timeFrom), s2 = Math.min(s2, this.options.timeTo), { ...e2, height: (s2 - t2) * this.timeScale, top: (t2 - this.options.timeFrom) * this.timeScale };
  });
}, events() {
  const { startDate: e2, endDate: t2 } = this.data;
  let s2 = [];
  if (!["years", "year"].includes(this.view.id) || this.options.eventsCountOnYearView) {
    if (s2 = this.view.events.slice(0), "month" === this.view.id && s2.push(...this.view.outOfScopeEvents), s2 = s2.filter((s3) => this.utils.event.eventInRange(s3, e2, t2)), this.options.showAllDayEvents && "month" !== this.view.id && (s2 = s2.filter((e3) => !!e3.allDay === this.allDay)), this.options.time && this.isWeekOrDayView && !this.allDay) {
      const { timeFrom: e3, timeTo: t3 } = this.options;
      s2 = s2.filter((s3) => {
        const i2 = s3.daysCount > 1 && s3.segments[this.data.formattedDate] || {}, n2 = 1 === s3.daysCount && s3.startTimeMinutes < t3 && s3.endTimeMinutes > e3, a2 = s3.daysCount > 1 && i2.startTimeMinutes < t3 && i2.endTimeMinutes > e3;
        return s3.allDay || n2 || a2 || false;
      });
    }
    !this.options.time || !this.isWeekOrDayView || this.options.showAllDayEvents && this.allDay || s2.sort((e3, t3) => e3.start < t3.start ? -1 : 1), this.cellSplits.length || this.$nextTick(this.checkCellOverlappingEvents);
  }
  return s2;
}, eventsCount() {
  return this.events.length;
}, splits() {
  return this.cellSplits.map((e2, t2) => {
    const s2 = this.events.filter((t3) => t3.split === e2.id), [i2, n2] = this.utils.event.checkCellOverlappingEvents(s2.filter((e3) => !e3.background && !e3.allDay), this.options);
    return { ...e2, overlaps: i2, overlapsStreak: n2, events: s2 };
  });
}, splitsCount() {
  return this.splits.length;
}, cellClasses() {
  return { [this.data.class]: !!this.data.class, "vuecal__cell--current": this.data.current, "vuecal__cell--today": this.data.today, "vuecal__cell--out-of-scope": this.data.outOfScope, "vuecal__cell--before-min": this.isDisabled && this.isBeforeMinDate, "vuecal__cell--after-max": this.isDisabled && this.isAfterMaxDate, "vuecal__cell--disabled": this.isDisabled, "vuecal__cell--selected": this.isSelected, "vuecal__cell--highlighted": this.highlighted, "vuecal__cell--has-splits": this.splitsCount, "vuecal__cell--has-events": this.eventsCount };
}, cellStyles() {
  return { ...this.cellWidth ? { width: `${this.cellWidth}%` } : {} };
}, timelineVisible() {
  const { time: e2, timeTo: t2 } = this.options;
  return this.data.today && this.isWeekOrDayView && e2 && !this.allDay && this.nowInMinutes <= t2;
}, todaysTimePosition() {
  if (!this.data.today || !this.options.time)
    return;
  const e2 = this.nowInMinutes - this.options.timeFrom;
  return Math.round(e2 * this.timeScale);
}, timeScale() {
  return this.options.timeCellHeight / this.options.timeStep;
} } }, [["render", function(l2, r2, d2, h2, v2, w2) {
  const y2 = p("event");
  return e(), m(f, { class: n(["vuecal__cell", w2.cellClasses]), name: `slide-fade--${w2.transitionDirection}`, tag: "div", appear: d2.options.transitions, style: a(w2.cellStyles) }, { default: o(() => [(e(true), t(s, null, i(w2.splitsCount ? w2.splits : 1, (h3, v3) => (e(), t("div", { class: n(["vuecal__flex vuecal__cell-content", w2.splitsCount && w2.splitClasses(h3)]), key: d2.options.transitions ? `${w2.view.id}-${d2.data.content}-${v3}` : v3, "data-split": !!w2.splitsCount && h3.id, column: "", tabindex: "0", "aria-label": d2.data.content, onFocus: r2[0] || (r2[0] = (e2) => w2.onCellFocus(e2)), onKeypress: r2[1] || (r2[1] = D((e2) => w2.onCellkeyPressEnter(e2), ["enter"])), onTouchstart: (e2) => !w2.isDisabled && w2.onCellTouchStart(e2, w2.splitsCount ? h3.id : null), onMousedown: (e2) => !w2.isDisabled && w2.onCellMouseDown(e2, w2.splitsCount ? h3.id : null), onClick: r2[2] || (r2[2] = (e2) => !w2.isDisabled && w2.onCellClick(e2)), onDblclick: r2[3] || (r2[3] = (e2) => !w2.isDisabled && w2.onCellDblClick(e2)), onContextmenu: r2[4] || (r2[4] = (e2) => !w2.isDisabled && d2.options.cellContextmenu && w2.onCellContextMenu(e2)), onDragenter: r2[5] || (r2[5] = (e2) => !w2.isDisabled && d2.editEvents.drag && w2.dnd && w2.dnd.cellDragEnter(e2, l2.$data, d2.data.startDate)), onDragover: (e2) => !w2.isDisabled && d2.editEvents.drag && w2.dnd && w2.dnd.cellDragOver(e2, l2.$data, d2.data.startDate, w2.splitsCount ? h3.id : null), onDragleave: r2[6] || (r2[6] = (e2) => !w2.isDisabled && d2.editEvents.drag && w2.dnd && w2.dnd.cellDragLeave(e2, l2.$data, d2.data.startDate)), onDrop: (e2) => !w2.isDisabled && d2.editEvents.drag && w2.dnd && w2.dnd.cellDragDrop(e2, l2.$data, d2.data.startDate, w2.splitsCount ? h3.id : null) }, [w2.isWeekOrDayView && !d2.allDay && w2.specialHours.length ? (e(true), t(s, { key: 0 }, i(w2.specialHours, (s2, i2) => (e(), t("div", { class: n(["vuecal__special-hours", `vuecal__special-hours--day${s2.day} ${s2.class}`]), style: a(`height: ${s2.height}px;top: ${s2.top}px`) }, null, 6))), 256)) : c("", true), u(l2.$slots, "cell-content", { events: w2.events, selectCell: (e2) => w2.selectCell(e2, true), split: !!w2.splitsCount && h3 }), w2.eventsCount && (w2.isWeekOrDayView || "month" === w2.view.id && d2.options.eventsOnMonthView) ? (e(), t("div", se, [(e(true), t(s, null, i(w2.splitsCount ? h3.events : w2.events, (t2, s2) => (e(), m(y2, { key: s2, "cell-formatted-date": d2.data.formattedDate, event: t2, "all-day": d2.allDay, "cell-events": w2.splitsCount ? h3.events : w2.events, overlaps: ((w2.splitsCount ? h3.overlaps[t2._eid] : l2.cellOverlaps[t2._eid]) || []).overlaps, "event-position": ((w2.splitsCount ? h3.overlaps[t2._eid] : l2.cellOverlaps[t2._eid]) || []).position, "overlaps-streak": w2.splitsCount ? h3.overlapsStreak : l2.cellOverlapsStreak }, { event: o(({ event: e2, view: t3 }) => [u(l2.$slots, "event", { view: t3, event: e2 })]), _: 2 }, 1032, ["cell-formatted-date", "event", "all-day", "cell-events", "overlaps", "event-position", "overlaps-streak"]))), 128))])) : c("", true)], 42, te))), 128)), w2.timelineVisible ? (e(), t("div", { class: "vuecal__now-line", style: a(`top: ${w2.todaysTimePosition}px`), key: d2.options.transitions ? `${w2.view.id}-now-line` : "now-line", title: w2.utils.date.formatTime(w2.vuecal.now) }, null, 12, ie)) : c("", true)]), _: 3 }, 8, ["class", "name", "appear", "style"]);
}]]);
const ae = { key: 0, class: "vuecal__all-day-text", style: { width: "3em" } };
var le = z({ inject: ["vuecal", "view", "editEvents"], components: { "vuecal-cell": ne }, props: { options: { type: Object, required: true }, cells: { type: Array, required: true }, label: { type: String, required: true }, daySplits: { type: Array, default: () => [] }, shortEvents: { type: Boolean, default: true }, height: { type: String, default: "" }, cellOrSplitMinWidth: { type: Number, default: null } }, computed: { hasCellOrSplitWidth() {
  return !!(this.options.minCellWidth || this.daySplits.length && this.options.minSplitWidth);
} } }, [["render", function(l2, r2, v2, w2, y2, D2) {
  const g2 = p("vuecal-cell");
  return e(), t("div", { class: "vuecal__flex vuecal__all-day", style: a(v2.cellOrSplitMinWidth && { height: v2.height }) }, [v2.cellOrSplitMinWidth ? c("", true) : (e(), t("div", ae, [d("span", null, h(v2.label), 1)])), d("div", { class: n(["vuecal__flex vuecal__cells", `${D2.view.id}-view`]), grow: "", style: a(v2.cellOrSplitMinWidth ? `min-width: ${v2.cellOrSplitMinWidth}px` : "") }, [(e(true), t(s, null, i(v2.cells, (t2, s2) => (e(), m(g2, { key: s2, options: v2.options, "edit-events": D2.editEvents, data: t2, "all-day": true, "cell-width": v2.options.hideWeekdays.length && (D2.vuecal.isWeekView || D2.vuecal.isMonthView) && D2.vuecal.cellWidth, "min-timestamp": v2.options.minTimestamp, "max-timestamp": v2.options.maxTimestamp, "cell-splits": v2.daySplits }, { event: o(({ event: e2, view: t3 }) => [u(l2.$slots, "event", { view: t3, event: e2 })]), _: 2 }, 1032, ["options", "edit-events", "data", "cell-width", "min-timestamp", "max-timestamp", "cell-splits"]))), 128))], 6)], 4);
}]]);
const re = ["lang"], oe = v("\xA0"), de = d("i", { class: "angle" }, null, -1), ue = v("\xA0"), he = v("\xA0"), ce = d("i", { class: "angle" }, null, -1), ve = v("\xA0"), pe = { class: "default" }, me = { key: 0, class: "vuecal__flex vuecal__body", grow: "" }, we = ["onBlur", "innerHTML"], ye = ["innerHTML"], De = ["innerHTML"], ge = { class: "vuecal__flex", row: "", grow: "" }, fe = { key: 0, class: "vuecal__time-column" }, _e = d("span", { class: "vuecal__time-cell-line" }, null, -1), be = { class: "vuecal__time-cell-label" }, ke = { key: 1, class: "vuecal__flex vuecal__week-numbers", column: "" }, Me = ["wrap", "column"], Te = ["onBlur", "innerHTML"], Ee = ["innerHTML"], Ce = ["innerHTML"], Se = ["wrap"], Oe = ["innerHTML"], $e = ["innerHTML"], xe = { key: 2, class: "vuecal__cell-events-count" }, He = { key: 3, class: "vuecal__no-event" }, We = ["onBlur", "innerHTML"], je = ["innerHTML"], Ae = { key: 2, class: "vuecal__event-time" }, Ve = { key: 0 }, Ye = { key: 1, class: "days-to-end" }, Le = ["innerHTML"], Fe = { key: 0, class: "vuecal__scrollbar-check" }, Be = [d("div", null, null, -1)];
const Ne = { weekDays: Array(7).fill(""), weekDaysShort: [], months: Array(12).fill(""), years: "", year: "", month: "", week: "", day: "", today: "", noEvent: "", allDay: "", deleteEvent: "", createEvent: "", dateFormat: "dddd MMMM D, YYYY", am: "am", pm: "pm" }, ze = ["years", "year", "month", "week", "day"], Ie = new class {
  constructor(e2, t2 = false) {
    __publicField(this, "texts", {});
    __publicField(this, "dateToMinutes", (e2) => 60 * e2.getHours() + e2.getMinutes());
    E = this, this._texts = e2, t2 || !Date || Date.prototype.addDays || this._initDatePrototypes();
  }
  _initDatePrototypes() {
    Date.prototype.addDays = function(e2) {
      return E.addDays(this, e2);
    }, Date.prototype.subtractDays = function(e2) {
      return E.subtractDays(this, e2);
    }, Date.prototype.addHours = function(e2) {
      return E.addHours(this, e2);
    }, Date.prototype.subtractHours = function(e2) {
      return E.subtractHours(this, e2);
    }, Date.prototype.addMinutes = function(e2) {
      return E.addMinutes(this, e2);
    }, Date.prototype.subtractMinutes = function(e2) {
      return E.subtractMinutes(this, e2);
    }, Date.prototype.getWeek = function() {
      return E.getWeek(this);
    }, Date.prototype.isToday = function() {
      return E.isToday(this);
    }, Date.prototype.isLeapYear = function() {
      return E.isLeapYear(this);
    }, Date.prototype.format = function(e2 = "YYYY-MM-DD") {
      return E.formatDate(this, e2);
    }, Date.prototype.formatTime = function(e2 = "HH:mm") {
      return E.formatTime(this, e2);
    };
  }
  removePrototypes() {
    delete Date.prototype.addDays, delete Date.prototype.subtractDays, delete Date.prototype.addHours, delete Date.prototype.subtractHours, delete Date.prototype.addMinutes, delete Date.prototype.subtractMinutes, delete Date.prototype.getWeek, delete Date.prototype.isToday, delete Date.prototype.isLeapYear, delete Date.prototype.format, delete Date.prototype.formatTime;
  }
  updateTexts(e2) {
    this._texts = e2;
  }
  _todayFormatted() {
    return M !== new Date().getDate() && (k = new Date(), M = k.getDate(), T = `${k.getFullYear()}-${k.getMonth()}-${k.getDate()}`), T;
  }
  addDays(e2, t2) {
    const s2 = new Date(e2.valueOf());
    return s2.setDate(s2.getDate() + t2), s2;
  }
  subtractDays(e2, t2) {
    const s2 = new Date(e2.valueOf());
    return s2.setDate(s2.getDate() - t2), s2;
  }
  addHours(e2, t2) {
    const s2 = new Date(e2.valueOf());
    return s2.setHours(s2.getHours() + t2), s2;
  }
  subtractHours(e2, t2) {
    const s2 = new Date(e2.valueOf());
    return s2.setHours(s2.getHours() - t2), s2;
  }
  addMinutes(e2, t2) {
    const s2 = new Date(e2.valueOf());
    return s2.setMinutes(s2.getMinutes() + t2), s2;
  }
  subtractMinutes(e2, t2) {
    const s2 = new Date(e2.valueOf());
    return s2.setMinutes(s2.getMinutes() - t2), s2;
  }
  getWeek(e2) {
    const t2 = new Date(Date.UTC(e2.getFullYear(), e2.getMonth(), e2.getDate())), s2 = t2.getUTCDay() || 7;
    t2.setUTCDate(t2.getUTCDate() + 4 - s2);
    const i2 = new Date(Date.UTC(t2.getUTCFullYear(), 0, 1));
    return Math.ceil(((t2 - i2) / 864e5 + 1) / 7);
  }
  isToday(e2) {
    return `${e2.getFullYear()}-${e2.getMonth()}-${e2.getDate()}` === this._todayFormatted();
  }
  isLeapYear(e2) {
    const t2 = e2.getFullYear();
    return !(t2 % 400) || t2 % 100 && !(t2 % 4);
  }
  getPreviousFirstDayOfWeek(e2 = null, t2) {
    const s2 = e2 && new Date(e2.valueOf()) || new Date(), i2 = t2 ? 7 : 6;
    return s2.setDate(s2.getDate() - (s2.getDay() + i2) % 7), s2;
  }
  stringToDate(e2) {
    return e2 instanceof Date ? e2 : (10 === e2.length && (e2 += " 00:00"), new Date(e2.replace(/-/g, "/")));
  }
  countDays(e2, t2) {
    "string" == typeof e2 && (e2 = e2.replace(/-/g, "/")), "string" == typeof t2 && (t2 = t2.replace(/-/g, "/")), e2 = new Date(e2).setHours(0, 0, 0, 0), t2 = new Date(t2).setHours(0, 0, 1, 0);
    const s2 = 60 * (new Date(t2).getTimezoneOffset() - new Date(e2).getTimezoneOffset()) * 1e3;
    return Math.ceil((t2 - e2 - s2) / 864e5);
  }
  datesInSameTimeStep(e2, t2, s2) {
    return Math.abs(e2.getTime() - t2.getTime()) <= 60 * s2 * 1e3;
  }
  formatDate(e2, t2 = "YYYY-MM-DD", s2 = null) {
    if (s2 || (s2 = this._texts), t2 || (t2 = "YYYY-MM-DD"), "YYYY-MM-DD" === t2)
      return this.formatDateLite(e2);
    C = {}, S = {};
    const i2 = { YYYY: () => this._hydrateDateObject(e2, s2).YYYY, YY: () => this._hydrateDateObject(e2, s2).YY(), M: () => this._hydrateDateObject(e2, s2).M, MM: () => this._hydrateDateObject(e2, s2).MM(), MMM: () => this._hydrateDateObject(e2, s2).MMM(), MMMM: () => this._hydrateDateObject(e2, s2).MMMM(), MMMMG: () => this._hydrateDateObject(e2, s2).MMMMG(), D: () => this._hydrateDateObject(e2, s2).D, DD: () => this._hydrateDateObject(e2, s2).DD(), S: () => this._hydrateDateObject(e2, s2).S(), d: () => this._hydrateDateObject(e2, s2).d, dd: () => this._hydrateDateObject(e2, s2).dd(), ddd: () => this._hydrateDateObject(e2, s2).ddd(), dddd: () => this._hydrateDateObject(e2, s2).dddd(), HH: () => this._hydrateTimeObject(e2, s2).HH, H: () => this._hydrateTimeObject(e2, s2).H, hh: () => this._hydrateTimeObject(e2, s2).hh, h: () => this._hydrateTimeObject(e2, s2).h, am: () => this._hydrateTimeObject(e2, s2).am, AM: () => this._hydrateTimeObject(e2, s2).AM, mm: () => this._hydrateTimeObject(e2, s2).mm, m: () => this._hydrateTimeObject(e2, s2).m };
    return t2.replace(/(\{[a-zA-Z]+\}|[a-zA-Z]+)/g, (e3, t3) => {
      const s3 = i2[t3.replace(/\{|\}/g, "")];
      return void 0 !== s3 ? s3() : t3;
    });
  }
  formatDateLite(e2) {
    const t2 = e2.getMonth() + 1, s2 = e2.getDate();
    return `${e2.getFullYear()}-${t2 < 10 ? "0" : ""}${t2}-${s2 < 10 ? "0" : ""}${s2}`;
  }
  formatTime(e2, t2 = "HH:mm", s2 = null, i2 = false) {
    let n2 = false;
    if (i2) {
      const [t3, s3, i3] = [e2.getHours(), e2.getMinutes(), e2.getSeconds()];
      t3 + s3 + i3 === 141 && (n2 = true);
    }
    if (e2 instanceof Date && "HH:mm" === t2)
      return n2 ? "24:00" : this.formatTimeLite(e2);
    S = {}, s2 || (s2 = this._texts);
    const a2 = this._hydrateTimeObject(e2, s2), l2 = t2.replace(/(\{[a-zA-Z]+\}|[a-zA-Z]+)/g, (e3, t3) => {
      const s3 = a2[t3.replace(/\{|\}/g, "")];
      return void 0 !== s3 ? s3 : t3;
    });
    return n2 ? l2.replace("23:59", "24:00") : l2;
  }
  formatTimeLite(e2) {
    const t2 = e2.getHours(), s2 = e2.getMinutes();
    return `${(t2 < 10 ? "0" : "") + t2}:${(s2 < 10 ? "0" : "") + s2}`;
  }
  _nth(e2) {
    if (e2 > 3 && e2 < 21)
      return "th";
    switch (e2 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  }
  _hydrateDateObject(e2, t2) {
    if (C.D)
      return C;
    const s2 = e2.getFullYear(), i2 = e2.getMonth() + 1, n2 = e2.getDate(), a2 = (e2.getDay() - 1 + 7) % 7;
    return C = { YYYY: s2, YY: () => s2.toString().substring(2), M: i2, MM: () => (i2 < 10 ? "0" : "") + i2, MMM: () => t2.months[i2 - 1].substring(0, 3), MMMM: () => t2.months[i2 - 1], MMMMG: () => (t2.monthsGenitive || t2.months)[i2 - 1], D: n2, DD: () => (n2 < 10 ? "0" : "") + n2, S: () => this._nth(n2), d: a2 + 1, dd: () => t2.weekDays[a2][0], ddd: () => t2.weekDays[a2].substr(0, 3), dddd: () => t2.weekDays[a2] }, C;
  }
  _hydrateTimeObject(e2, t2) {
    if (S.am)
      return S;
    let s2, i2;
    e2 instanceof Date ? (s2 = e2.getHours(), i2 = e2.getMinutes()) : (s2 = Math.floor(e2 / 60), i2 = Math.floor(e2 % 60));
    const n2 = s2 % 12 ? s2 % 12 : 12, a2 = (t2 || { am: "am", pm: "pm" })[24 === s2 || s2 < 12 ? "am" : "pm"];
    return S = { H: s2, h: n2, HH: (s2 < 10 ? "0" : "") + s2, hh: (n2 < 10 ? "0" : "") + n2, am: a2, AM: a2.toUpperCase(), m: i2, mm: (i2 < 10 ? "0" : "") + i2 }, S;
  }
}(Ne), Pe = { name: "vue-cal", components: { "vuecal-cell": ne, "vuecal-header": J, WeekdaysHeadings: I, AllDayBar: le }, provide() {
  return { vuecal: this, utils: this.utils, modules: this.modules, previous: this.previous, next: this.next, switchView: this.switchView, updateSelectedDate: this.updateSelectedDate, editEvents: this.editEvents, view: this.view, domEvents: this.domEvents };
}, props: { activeView: { type: String, default: "week" }, allDayBarHeight: { type: [String, Number], default: "25px" }, cellClickHold: { type: Boolean, default: true }, cellContextmenu: { type: Boolean, default: false }, clickToNavigate: { type: Boolean, default: false }, dblclickToNavigate: { type: Boolean, default: true }, disableDatePrototypes: { type: Boolean, default: false }, disableDays: { type: Array, default: () => [] }, disableViews: { type: Array, default: () => [] }, dragToCreateEvent: { type: Boolean, default: true }, dragToCreateThreshold: { type: Number, default: 15 }, editableEvents: { type: [Boolean, Object], default: false }, events: { type: Array, default: () => [] }, eventsCountOnYearView: { type: Boolean, default: false }, eventsOnMonthView: { type: [Boolean, String], default: false }, hideBody: { type: Boolean, default: false }, hideTitleBar: { type: Boolean, default: false }, hideViewSelector: { type: Boolean, default: false }, hideWeekdays: { type: Array, default: () => [] }, hideWeekends: { type: Boolean, default: false }, locale: { type: [String, Object], default: "en" }, maxDate: { type: [String, Date], default: "" }, minCellWidth: { type: Number, default: 0 }, minDate: { type: [String, Date], default: "" }, minEventWidth: { type: Number, default: 0 }, minSplitWidth: { type: Number, default: 0 }, onEventClick: { type: [Function, null], default: null }, onEventCreate: { type: [Function, null], default: null }, onEventDblclick: { type: [Function, null], default: null }, overlapsPerTimeStep: { type: Boolean, default: false }, resizeX: { type: Boolean, default: false }, selectedDate: { type: [String, Date], default: "" }, showAllDayEvents: { type: [Boolean, String], default: false }, showWeekNumbers: { type: [Boolean, String], default: false }, snapToTime: { type: Number, default: 0 }, small: { type: Boolean, default: false }, specialHours: { type: Object, default: () => ({}) }, splitDays: { type: Array, default: () => [] }, startWeekOnSunday: { type: Boolean, default: false }, stickySplitLabels: { type: Boolean, default: false }, time: { type: Boolean, default: true }, timeCellHeight: { type: Number, default: 40 }, timeFormat: { type: String, default: "" }, timeFrom: { type: Number, default: 0 }, timeStep: { type: Number, default: 60 }, timeTo: { type: Number, default: 1440 }, todayButton: { type: Boolean, default: false }, transitions: { type: Boolean, default: true }, twelveHour: { type: Boolean, default: false }, watchRealTime: { type: Boolean, default: false }, xsmall: { type: Boolean, default: false } }, data() {
  return { ready: false, texts: { ...Ne }, utils: { date: !!this.disableDatePrototypes && Ie.removePrototypes() || Ie, cell: null, event: null }, modules: { dnd: null }, cellsEl: null, view: { id: "", title: "", startDate: null, endDate: null, firstCellDate: null, lastCellDate: null, selectedDate: null, events: [] }, eventIdIncrement: 1, now: new Date(), timeTickerIds: [null, null], domEvents: { resizeAnEvent: { _eid: null, start: null, split: null, segment: null, originalEndTimeMinutes: 0, originalEnd: null, end: null, startCell: null, endCell: null }, dragAnEvent: { _eid: null }, dragCreateAnEvent: { startCursorY: null, start: null, split: null, event: null }, focusAnEvent: { _eid: null, mousedUp: false }, clickHoldAnEvent: { _eid: null, timeout: 1200, timeoutId: null }, dblTapACell: { taps: 0, timeout: 500 }, clickHoldACell: { cellId: null, split: null, timeout: 1200, timeoutId: null, eventCreated: false }, cancelClickEventCreation: false }, mutableEvents: [], transitionDirection: "right" };
}, methods: { async loadLocale(e2) {
  if ("object" == typeof this.locale)
    return this.texts = Object.assign({}, Ne, e2), void this.utils.date.updateTexts(this.texts);
  if ("en" === this.locale) {
    const e3 = await import("./i18n/en.es.js");
    this.texts = Object.assign({}, Ne, e3);
  } else
    (function(e3) {
      switch (e3) {
        case "./i18n/ar.json":
          return import("./i18n/ar.es.js");
        case "./i18n/bg.json":
          return import("./i18n/bg.es.js");
        case "./i18n/bn.json":
          return import("./i18n/bn.es.js");
        case "./i18n/bs.json":
          return import("./i18n/bs.es.js");
        case "./i18n/ca.json":
          return import("./i18n/ca.es.js");
        case "./i18n/cs.json":
          return import("./i18n/cs.es.js");
        case "./i18n/da.json":
          return import("./i18n/da.es.js");
        case "./i18n/de.json":
          return import("./i18n/de.es.js");
        case "./i18n/el.json":
          return import("./i18n/el.es.js");
        case "./i18n/en.json":
          return import("./i18n/en.es.js");
        case "./i18n/es.json":
          return import("./i18n/es.es.js");
        case "./i18n/fa.json":
          return import("./i18n/fa.es.js");
        case "./i18n/fr.json":
          return import("./i18n/fr.es.js");
        case "./i18n/he.json":
          return import("./i18n/he.es.js");
        case "./i18n/hr.json":
          return import("./i18n/hr.es.js");
        case "./i18n/hu.json":
          return import("./i18n/hu.es.js");
        case "./i18n/id.json":
          return import("./i18n/id.es.js");
        case "./i18n/is.json":
          return import("./i18n/is.es.js");
        case "./i18n/it.json":
          return import("./i18n/it.es.js");
        case "./i18n/ja.json":
          return import("./i18n/ja.es.js");
        case "./i18n/ka.json":
          return import("./i18n/ka.es.js");
        case "./i18n/ko.json":
          return import("./i18n/ko.es.js");
        case "./i18n/lt.json":
          return import("./i18n/lt.es.js");
        case "./i18n/mn.json":
          return import("./i18n/mn.es.js");
        case "./i18n/nl.json":
          return import("./i18n/nl.es.js");
        case "./i18n/no.json":
          return import("./i18n/no.es.js");
        case "./i18n/pl.json":
          return import("./i18n/pl.es.js");
        case "./i18n/pt-br.json":
          return import("./i18n/pt-br.es.js");
        case "./i18n/ro.json":
          return import("./i18n/ro.es.js");
        case "./i18n/ru.json":
          return import("./i18n/ru.es.js");
        case "./i18n/sk.json":
          return import("./i18n/sk.es.js");
        case "./i18n/sl.json":
          return import("./i18n/sl.es.js");
        case "./i18n/sq.json":
          return import("./i18n/sq.es.js");
        case "./i18n/sr.json":
          return import("./i18n/sr.es.js");
        case "./i18n/sv.json":
          return import("./i18n/sv.es.js");
        case "./i18n/tr.json":
          return import("./i18n/tr.es.js");
        case "./i18n/uk.json":
          return import("./i18n/uk.es.js");
        case "./i18n/vi.json":
          return import("./i18n/vi.es.js");
        case "./i18n/zh-cn.json":
          return import("./i18n/zh-cn.es.js");
        case "./i18n/zh-hk.json":
          return import("./i18n/zh-hk.es.js");
        default:
          return new Promise(function(t2, s2) {
            ("function" == typeof queueMicrotask ? queueMicrotask : setTimeout)(s2.bind(null, new Error("Unknown variable dynamic import: " + e3)));
          });
      }
    })(`./i18n/${e2}.json`).then((e3) => {
      this.texts = Object.assign({}, Ne, e3.default), this.utils.date.updateTexts(this.texts);
    });
}, loadDragAndDrop() {
  import("./drag-and-drop.es.js").then((e2) => {
    const { DragAndDrop: t2 } = e2;
    this.modules.dnd = new t2(this);
  }).catch(() => console.warn("Vue Cal: Missing drag & drop module."));
}, validateView(e2) {
  return ze.includes(e2) || (console.error(`Vue Cal: invalid active-view parameter provided: "${e2}".
A valid view must be one of: ${ze.join(", ")}.`), e2 = "week"), this.enabledViews.includes(e2) || (console.warn(`Vue Cal: the provided active-view "${e2}" is disabled. Using the "${this.enabledViews[0]}" view instead.`), e2 = this.enabledViews[0]), e2;
}, switchToNarrowerView(e2 = null) {
  this.transitionDirection = "right";
  const t2 = this.enabledViews[this.enabledViews.indexOf(this.view.id) + 1];
  t2 && this.switchView(t2, e2);
}, switchView(e2, t2 = null, s2 = false) {
  e2 = this.validateView(e2);
  const i2 = this.utils.date, n2 = this.view.startDate && this.view.startDate.getTime();
  if (this.transitions && s2) {
    if (this.view.id === e2)
      return;
    const t3 = this.enabledViews;
    this.transitionDirection = t3.indexOf(this.view.id) > t3.indexOf(e2) ? "left" : "right";
  }
  const a2 = this.view.id;
  switch (this.view.events = [], this.view.id = e2, this.view.firstCellDate = null, this.view.lastCellDate = null, t2 || (t2 = this.view.selectedDate || this.view.startDate), e2) {
    case "years":
      this.view.startDate = new Date(25 * Math.floor(t2.getFullYear() / 25) || 2e3, 0, 1), this.view.endDate = new Date(this.view.startDate.getFullYear() + 25, 0, 1), this.view.endDate.setSeconds(-1);
      break;
    case "year":
      this.view.startDate = new Date(t2.getFullYear(), 0, 1), this.view.endDate = new Date(t2.getFullYear() + 1, 0, 1), this.view.endDate.setSeconds(-1);
      break;
    case "month": {
      this.view.startDate = new Date(t2.getFullYear(), t2.getMonth(), 1), this.view.endDate = new Date(t2.getFullYear(), t2.getMonth() + 1, 1), this.view.endDate.setSeconds(-1);
      let e3 = new Date(this.view.startDate);
      if (e3.getDay() !== (this.startWeekOnSunday ? 0 : 1) && (e3 = i2.getPreviousFirstDayOfWeek(e3, this.startWeekOnSunday)), this.view.firstCellDate = e3, this.view.lastCellDate = i2.addDays(e3, 41), this.view.lastCellDate.setHours(23, 59, 59, 0), this.hideWeekends) {
        if ([0, 6].includes(this.view.firstCellDate.getDay())) {
          const e4 = 6 !== this.view.firstCellDate.getDay() || this.startWeekOnSunday ? 1 : 2;
          this.view.firstCellDate = i2.addDays(this.view.firstCellDate, e4);
        }
        if ([0, 6].includes(this.view.startDate.getDay())) {
          const e4 = 6 === this.view.startDate.getDay() ? 2 : 1;
          this.view.startDate = i2.addDays(this.view.startDate, e4);
        }
        if ([0, 6].includes(this.view.lastCellDate.getDay())) {
          const e4 = 0 !== this.view.lastCellDate.getDay() || this.startWeekOnSunday ? 1 : 2;
          this.view.lastCellDate = i2.subtractDays(this.view.lastCellDate, e4);
        }
        if ([0, 6].includes(this.view.endDate.getDay())) {
          const e4 = 0 === this.view.endDate.getDay() ? 2 : 1;
          this.view.endDate = i2.subtractDays(this.view.endDate, e4);
        }
      }
      break;
    }
    case "week": {
      t2 = i2.getPreviousFirstDayOfWeek(t2, this.startWeekOnSunday);
      const e3 = this.hideWeekends ? 5 : 7;
      this.view.startDate = this.hideWeekends && this.startWeekOnSunday ? i2.addDays(t2, 1) : t2, this.view.startDate.setHours(0, 0, 0, 0), this.view.endDate = i2.addDays(t2, e3), this.view.endDate.setSeconds(-1);
      break;
    }
    case "day":
      this.view.startDate = t2, this.view.startDate.setHours(0, 0, 0, 0), this.view.endDate = new Date(t2), this.view.endDate.setHours(23, 59, 59, 0);
  }
  this.addEventsToView();
  const l2 = this.view.startDate && this.view.startDate.getTime();
  if ((a2 !== e2 || l2 !== n2) && (this.$emit("update:activeView", e2), this.ready)) {
    const t3 = this.view.startDate, s3 = { view: e2, startDate: t3, endDate: this.view.endDate, ...this.isMonthView ? { firstCellDate: this.view.firstCellDate, lastCellDate: this.view.lastCellDate, outOfScopeEvents: this.view.outOfScopeEvents.map(this.cleanupEvent) } : {}, events: this.view.events.map(this.cleanupEvent), ...this.isWeekView ? { week: i2.getWeek(this.startWeekOnSunday ? i2.addDays(t3, 1) : t3) } : {} };
    this.$emit("view-change", s3);
  }
}, previous() {
  this.previousNext(false);
}, next() {
  this.previousNext();
}, previousNext(e2 = true) {
  const t2 = this.utils.date;
  this.transitionDirection = e2 ? "right" : "left";
  const s2 = e2 ? 1 : -1;
  let i2 = null;
  const { startDate: n2, id: a2 } = this.view;
  switch (a2) {
    case "years":
      i2 = new Date(n2.getFullYear() + 25 * s2, 0, 1);
      break;
    case "year":
      i2 = new Date(n2.getFullYear() + 1 * s2, 1, 1);
      break;
    case "month":
      i2 = new Date(n2.getFullYear(), n2.getMonth() + 1 * s2, 1);
      break;
    case "week":
      i2 = t2[e2 ? "addDays" : "subtractDays"](t2.getPreviousFirstDayOfWeek(n2, this.startWeekOnSunday), 7);
      break;
    case "day":
      i2 = t2[e2 ? "addDays" : "subtractDays"](n2, 1);
  }
  i2 && this.switchView(a2, i2);
}, addEventsToView(e2 = []) {
  const t2 = this.utils.event, { startDate: s2, endDate: i2, firstCellDate: n2, lastCellDate: a2 } = this.view;
  if (e2.length || (this.view.events = []), !(e2 = e2.length ? e2 : [...this.mutableEvents]) || this.isYearsOrYearView && !this.eventsCountOnYearView)
    return;
  let l2 = e2.filter((e3) => t2.eventInRange(e3, s2, i2));
  this.isYearsOrYearView || this.isMonthView && !this.eventsOnMonthView || (l2 = l2.map((e3) => e3.daysCount > 1 ? t2.createEventSegments(e3, n2 || s2, a2 || i2) : e3)), this.view.events.push(...l2), this.isMonthView && (this.view.outOfScopeEvents = [], e2.forEach((e3) => {
    (t2.eventInRange(e3, n2, s2) || t2.eventInRange(e3, i2, a2)) && (this.view.events.some((t3) => t3._eid === e3._eid) || this.view.outOfScopeEvents.push(e3));
  }));
}, findAncestor(e2, t2) {
  for (; (e2 = e2.parentElement) && !e2.classList.contains(t2); )
    ;
  return e2;
}, isDOMElementAnEvent(e2) {
  return e2.classList.contains("vuecal__event") || this.findAncestor(e2, "vuecal__event");
}, onMouseMove(e2) {
  const { resizeAnEvent: t2, dragAnEvent: s2, dragCreateAnEvent: i2 } = this.domEvents;
  (null !== t2._eid || null !== s2._eid || i2.start) && (e2.preventDefault(), t2._eid ? this.eventResizing(e2) : this.dragToCreateEvent && i2.start && this.eventDragCreation(e2));
}, onMouseUp(e2) {
  const { focusAnEvent: t2, resizeAnEvent: s2, clickHoldAnEvent: i2, clickHoldACell: n2, dragCreateAnEvent: a2 } = this.domEvents, { _eid: l2 } = i2, { _eid: r2 } = s2;
  let o2 = false;
  const { event: d2, start: u2 } = a2, h2 = this.isDOMElementAnEvent(e2.target), c2 = t2.mousedUp;
  if (t2.mousedUp = false, h2 && (this.domEvents.cancelClickEventCreation = true), n2.eventCreated)
    return;
  if (r2) {
    const { originalEnd: e3, originalEndTimeMinutes: t3, endTimeMinutes: i3 } = s2, n3 = this.view.events.find((e4) => e4._eid === s2._eid);
    if (o2 = i3 && i3 !== t3, n3 && n3.end.getTime() !== e3.getTime()) {
      const t4 = this.mutableEvents.find((e4) => e4._eid === s2._eid);
      t4.endTimeMinutes = n3.endTimeMinutes, t4.end = n3.end;
      const i4 = this.cleanupEvent(n3), a3 = { ...this.cleanupEvent(n3), end: e3, endTimeMinutes: n3.originalEndTimeMinutes };
      this.$emit("event-duration-change", { event: i4, oldDate: s2.originalEnd, originalEvent: a3 }), this.$emit("event-change", { event: i4, originalEvent: a3 });
    }
    n3 && (n3.resizing = false), s2._eid = null, s2.start = null, s2.split = null, s2.segment = null, s2.originalEndTimeMinutes = null, s2.originalEnd = null, s2.endTimeMinutes = null, s2.startCell = null, s2.endCell = null;
  } else
    u2 && (d2 && (this.emitWithEvent("event-drag-create", d2), a2.event.resizing = false), a2.start = null, a2.split = null, a2.event = null);
  h2 || r2 || this.unfocusEvent(), i2.timeoutId && !l2 && (clearTimeout(i2.timeoutId), i2.timeoutId = null), n2.timeoutId && (clearTimeout(n2.timeoutId), n2.timeoutId = null);
  const v2 = "function" == typeof this.onEventClick;
  if (c2 && !o2 && !l2 && !d2 && v2) {
    let s3 = this.view.events.find((e3) => e3._eid === t2._eid);
    return !s3 && this.isMonthView && (s3 = this.view.outOfScopeEvents.find((e3) => e3._eid === t2._eid)), s3 && this.onEventClick(s3, e2);
  }
}, onKeyUp(e2) {
  27 === e2.keyCode && this.cancelDelete();
}, eventResizing(e2) {
  const { resizeAnEvent: t2 } = this.domEvents, s2 = this.view.events.find((e3) => e3._eid === t2._eid) || { segments: {} }, { minutes: i2, cursorCoords: n2 } = this.minutesAtCursor(e2), a2 = s2.segments && s2.segments[t2.segment], { date: l2, event: r2 } = this.utils, o2 = Math.max(i2, this.timeFrom + 1, (a2 || s2).startTimeMinutes + 1);
  if (s2.endTimeMinutes = t2.endTimeMinutes = o2, this.snapToTime) {
    const e3 = s2.endTimeMinutes + this.snapToTime / 2;
    s2.endTimeMinutes = e3 - e3 % this.snapToTime;
  }
  if (a2 && (a2.endTimeMinutes = s2.endTimeMinutes), s2.end.setHours(0, s2.endTimeMinutes, 1440 === s2.endTimeMinutes ? -1 : 0, 0), this.resizeX && this.isWeekView) {
    s2.daysCount = l2.countDays(s2.start, s2.end);
    const e3 = this.cellsEl, i3 = e3.offsetWidth / e3.childElementCount, a3 = Math.floor(n2.x / i3);
    if (null === t2.startCell && (t2.startCell = a3 - (s2.daysCount - 1)), t2.endCell !== a3) {
      t2.endCell = a3;
      const e4 = l2.addDays(s2.start, a3 - t2.startCell), i4 = Math.max(l2.countDays(s2.start, e4), 1);
      if (i4 !== s2.daysCount) {
        let e5 = null;
        e5 = i4 > s2.daysCount ? r2.addEventSegment(s2) : r2.removeEventSegment(s2), t2.segment = e5, s2.endTimeMinutes += 1e-3;
      }
    }
  }
  this.$emit("event-resizing", { _eid: s2._eid, end: s2.end, endTimeMinutes: s2.endTimeMinutes });
}, eventDragCreation(e2) {
  const { dragCreateAnEvent: t2 } = this.domEvents, { start: s2, startCursorY: i2, split: n2 } = t2, a2 = new Date(s2), { minutes: l2, cursorCoords: { y: r2 } } = this.minutesAtCursor(e2);
  if (t2.event || !(Math.abs(i2 - r2) < this.dragToCreateThreshold))
    if (t2.event) {
      if (a2.setHours(0, l2, 1440 === l2 ? -1 : 0, 0), this.snapToTime) {
        let e4 = 60 * a2.getHours() + a2.getMinutes();
        const t3 = e4 + this.snapToTime / 2;
        e4 = t3 - t3 % this.snapToTime, a2.setHours(0, e4, 0, 0);
      }
      const e3 = s2 < a2, { event: i3 } = t2;
      i3.start = e3 ? s2 : a2, i3.end = e3 ? a2 : s2, i3.startTimeMinutes = 60 * i3.start.getHours() + i3.start.getMinutes(), i3.endTimeMinutes = 60 * i3.end.getHours() + i3.end.getMinutes();
    } else {
      if (t2.event = this.utils.event.createAnEvent(s2, 1, { split: n2 }), !t2.event)
        return t2.start = null, t2.split = null, void (t2.event = null);
      t2.event.resizing = true;
    }
}, unfocusEvent() {
  const { focusAnEvent: e2, clickHoldAnEvent: t2 } = this.domEvents, s2 = this.view.events.find((s3) => s3._eid === (e2._eid || t2._eid));
  e2._eid = null, t2._eid = null, s2 && (s2.focused = false, s2.deleting = false);
}, cancelDelete() {
  const { clickHoldAnEvent: e2 } = this.domEvents;
  if (e2._eid) {
    const t2 = this.view.events.find((t3) => t3._eid === e2._eid);
    t2 && (t2.deleting = false), e2._eid = null, e2.timeoutId = null;
  }
}, onEventTitleBlur(e2, t2) {
  if (t2.title === e2.target.innerHTML)
    return;
  const s2 = t2.title;
  t2.title = e2.target.innerHTML;
  const i2 = this.cleanupEvent(t2);
  this.$emit("event-title-change", { event: i2, oldTitle: s2 }), this.$emit("event-change", { event: i2, originalEvent: { ...i2, title: s2 } });
}, updateMutableEvents() {
  const e2 = this.utils.date;
  this.mutableEvents = [], this.events.forEach((t2) => {
    const s2 = "string" == typeof t2.start ? e2.stringToDate(t2.start) : t2.start, i2 = e2.formatDateLite(s2), n2 = e2.dateToMinutes(s2);
    let a2 = null;
    "string" == typeof t2.end && t2.end.includes("24:00") ? (a2 = new Date(t2.end.replace(" 24:00", "")), a2.setHours(23, 59, 59, 0)) : a2 = "string" == typeof t2.end ? e2.stringToDate(t2.end) : t2.end;
    let l2 = e2.formatDateLite(a2), r2 = e2.dateToMinutes(a2);
    r2 && 1440 !== r2 || (!this.time || "string" == typeof t2.end && 10 === t2.end.length ? a2.setHours(23, 59, 59, 0) : a2.setSeconds(a2.getSeconds() - 1), l2 = e2.formatDateLite(a2), r2 = 1440);
    const o2 = i2 !== l2;
    t2 = Object.assign({ ...this.utils.event.eventDefaults }, t2, { _eid: `${this._.uid}_${this.eventIdIncrement++}`, segments: o2 ? {} : null, start: s2, startTimeMinutes: n2, end: a2, endTimeMinutes: r2, daysCount: o2 ? e2.countDays(s2, a2) : 1, class: t2.class }), this.mutableEvents.push(t2);
  });
}, minutesAtCursor(e2) {
  return this.utils.cell.minutesAtCursor(e2);
}, createEvent(e2, t2, s2 = {}) {
  return this.utils.event.createAnEvent(e2, t2, s2);
}, cleanupEvent(e2) {
  e2 = { ...e2 };
  return ["segments", "deletable", "deleting", "titleEditable", "resizable", "resizing", "draggable", "dragging", "draggingStatic", "focused"].forEach((t2) => {
    t2 in e2 && delete e2[t2];
  }), e2.repeat || delete e2.repeat, e2;
}, emitWithEvent(e2, t2) {
  this.$emit(e2, this.cleanupEvent(t2));
}, updateSelectedDate(e2) {
  if ((e2 = e2 && "string" == typeof e2 ? this.utils.date.stringToDate(e2) : new Date(e2)) && e2 instanceof Date) {
    const { selectedDate: t2 } = this.view;
    t2 && (this.transitionDirection = t2.getTime() > e2.getTime() ? "left" : "right"), e2.setHours(0, 0, 0, 0), t2 && t2.getTime() === e2.getTime() || (this.view.selectedDate = e2), this.switchView(this.view.id);
  }
}, getWeekNumber(e2) {
  const t2 = this.utils.date, s2 = this.firstCellDateWeekNumber + e2, i2 = this.startWeekOnSunday ? 1 : 0;
  return s2 > 52 ? t2.getWeek(t2.addDays(this.view.firstCellDate, 7 * e2 + i2)) : s2;
}, timeTick() {
  this.now = new Date(), this.timeTickerIds[1] = setTimeout(this.timeTick, 6e4);
}, updateDateTexts() {
  this.utils.date.updateTexts(this.texts);
}, alignWithScrollbar() {
  if (document.getElementById("vuecal-align-with-scrollbar"))
    return;
  const e2 = this.$refs.vuecal.getElementsByClassName("vuecal__scrollbar-check")[0], t2 = e2.offsetWidth - e2.children[0].offsetWidth;
  if (t2) {
    const e3 = document.createElement("style");
    e3.id = "vuecal-align-with-scrollbar", e3.type = "text/css", e3.innerHTML = `.vuecal__weekdays-headings,.vuecal__all-day {padding-right: ${t2}px}`, document.head.appendChild(e3);
  }
}, cellOrSplitHasEvents: (e2, t2 = null) => e2.length && (!t2 && e2.length || t2 && e2.some((e3) => e3.split === t2.id)) }, created() {
  this.utils.cell = new O(this), this.utils.event = new W(this, this.utils.date), this.loadLocale(this.locale), this.editEvents.drag && this.loadDragAndDrop(), this.updateMutableEvents(this.events), this.view.id = this.currentView, this.selectedDate ? this.updateSelectedDate(this.selectedDate) : (this.view.selectedDate = new Date(), this.switchView(this.currentView)), this.time && this.watchRealTime && (this.timeTickerIds[0] = setTimeout(this.timeTick, 1e3 * (60 - this.now.getSeconds())));
}, mounted() {
  const e2 = this.utils.date, t2 = "ontouchstart" in window, { resize: s2, drag: i2, create: n2, delete: a2, title: l2 } = this.editEvents, r2 = this.onEventClick && "function" == typeof this.onEventClick;
  (s2 || i2 || n2 || a2 || l2 || r2) && window.addEventListener(t2 ? "touchend" : "mouseup", this.onMouseUp), (s2 || i2 || n2 && this.dragToCreateEvent) && window.addEventListener(t2 ? "touchmove" : "mousemove", this.onMouseMove, { passive: false }), l2 && window.addEventListener("keyup", this.onKeyUp), t2 && (this.$refs.vuecal.oncontextmenu = function(e3) {
    e3.preventDefault(), e3.stopPropagation();
  }), this.hideBody || this.alignWithScrollbar();
  const o2 = this.view.startDate, d2 = { view: this.view.id, startDate: o2, endDate: this.view.endDate, ...this.isMonthView ? { firstCellDate: this.view.firstCellDate, lastCellDate: this.view.lastCellDate } : {}, events: this.view.events.map(this.cleanupEvent), ...this.isWeekView ? { week: e2.getWeek(this.startWeekOnSunday ? e2.addDays(o2, 1) : o2) } : {} };
  this.$emit("ready", d2), this.ready = true;
}, beforeUnmount() {
  const e2 = "ontouchstart" in window;
  window.removeEventListener(e2 ? "touchmove" : "mousemove", this.onMouseMove, { passive: false }), window.removeEventListener(e2 ? "touchend" : "mouseup", this.onMouseUp), window.removeEventListener("keyup", this.onKeyUp), this.timeTickerIds[0] && clearTimeout(this.timeTickerIds[0]), this.timeTickerIds[1] && clearTimeout(this.timeTickerIds[1]), this.timeTickerIds = [null, null];
}, computed: { editEvents() {
  return this.editableEvents && "object" == typeof this.editableEvents ? { title: !!this.editableEvents.title, drag: !!this.editableEvents.drag, resize: !!this.editableEvents.resize, create: !!this.editableEvents.create, delete: !!this.editableEvents.delete } : { title: !!this.editableEvents, drag: !!this.editableEvents, resize: !!this.editableEvents, create: !!this.editableEvents, delete: !!this.editableEvents };
}, views() {
  return { years: { label: this.texts.years, enabled: !this.disableViews.includes("years") }, year: { label: this.texts.year, enabled: !this.disableViews.includes("year") }, month: { label: this.texts.month, enabled: !this.disableViews.includes("month") }, week: { label: this.texts.week, enabled: !this.disableViews.includes("week") }, day: { label: this.texts.day, enabled: !this.disableViews.includes("day") } };
}, currentView() {
  return this.validateView(this.activeView);
}, enabledViews() {
  return Object.keys(this.views).filter((e2) => this.views[e2].enabled);
}, hasTimeColumn() {
  return this.time && this.isWeekOrDayView;
}, isShortMonthView() {
  return this.isMonthView && "short" === this.eventsOnMonthView;
}, firstCellDateWeekNumber() {
  const e2 = this.utils.date, t2 = this.view.firstCellDate;
  return e2.getWeek(this.startWeekOnSunday ? e2.addDays(t2, 1) : t2);
}, timeCells() {
  const e2 = [];
  for (let t2 = this.timeFrom, s2 = this.timeTo; t2 < s2; t2 += this.timeStep)
    e2.push({ hours: Math.floor(t2 / 60), minutes: t2 % 60, label: this.utils.date.formatTime(t2, this.TimeFormat), value: t2 });
  return e2;
}, TimeFormat() {
  return this.timeFormat || (this.twelveHour ? "h:mm{am}" : "HH:mm");
}, daySplits() {
  return (this.splitDays.filter((e2) => !e2.hide) || []).map((e2, t2) => ({ ...e2, id: e2.id || t2 + 1 }));
}, hasSplits() {
  return this.daySplits.length && this.isWeekOrDayView;
}, hasShortEvents() {
  return "short" === this.showAllDayEvents;
}, cellOrSplitMinWidth() {
  let e2 = null;
  return this.hasSplits && this.minSplitWidth ? e2 = this.visibleDaysCount * this.minSplitWidth * this.daySplits.length : this.minCellWidth && this.isWeekView && (e2 = this.visibleDaysCount * this.minCellWidth), e2;
}, allDayBar() {
  let e2 = this.allDayBarHeight || null;
  return e2 && !isNaN(e2) && (e2 += "px"), { cells: this.viewCells, options: this.$props, label: this.texts.allDay, shortEvents: this.hasShortEvents, daySplits: this.hasSplits && this.daySplits || [], cellOrSplitMinWidth: this.cellOrSplitMinWidth, height: e2 };
}, minTimestamp() {
  let e2 = null;
  return this.minDate && "string" == typeof this.minDate ? e2 = this.utils.date.stringToDate(this.minDate) : this.minDate && this.minDate instanceof Date && (e2 = this.minDate), e2 ? e2.getTime() : null;
}, maxTimestamp() {
  let e2 = null;
  return this.maxDate && "string" == typeof this.maxDate ? e2 = this.utils.date.stringToDate(this.maxDate) : this.maxDate && this.minDate instanceof Date && (e2 = this.maxDate), e2 ? e2.getTime() : null;
}, weekDays() {
  let { weekDays: e2, weekDaysShort: t2 = [] } = this.texts;
  return e2 = e2.slice(0).map((e3, s2) => ({ label: e3, ...t2.length ? { short: t2[s2] } : {}, hide: this.hideWeekends && s2 >= 5 || this.hideWeekdays.length && this.hideWeekdays.includes(s2 + 1) })), this.startWeekOnSunday && e2.unshift(e2.pop()), e2;
}, weekDaysInHeader() {
  return this.isMonthView || this.isWeekView && !this.minCellWidth && !(this.hasSplits && this.minSplitWidth);
}, months() {
  return this.texts.months.map((e2) => ({ label: e2 }));
}, specialDayHours() {
  return this.specialHours && Object.keys(this.specialHours).length ? Array(7).fill("").map((e2, t2) => {
    let s2 = this.specialHours[t2 + 1] || [];
    return Array.isArray(s2) || (s2 = [s2]), e2 = [], s2.forEach(({ from: s3, to: i2, class: n2 }, a2) => {
      e2[a2] = { day: t2 + 1, from: [null, void 0].includes(s3) ? null : 1 * s3, to: [null, void 0].includes(i2) ? null : 1 * i2, class: n2 || "" };
    }), e2;
  }) : {};
}, viewTitle() {
  const e2 = this.utils.date;
  let t2 = "";
  const s2 = this.view.startDate, i2 = s2.getFullYear(), n2 = s2.getMonth();
  switch (this.view.id) {
    case "years":
      t2 = this.texts.years;
      break;
    case "year":
      t2 = i2;
      break;
    case "month":
      t2 = `${this.months[n2].label} ${i2}`;
      break;
    case "week": {
      const i3 = this.view.endDate, n3 = s2.getFullYear();
      let a2 = this.texts.months[s2.getMonth()];
      this.xsmall && (a2 = a2.substring(0, 3));
      let l2 = `${a2} ${n3}`;
      if (i3.getMonth() !== s2.getMonth()) {
        const e3 = i3.getFullYear();
        let t3 = this.texts.months[i3.getMonth()];
        this.xsmall && (t3 = t3.substring(0, 3)), l2 = n3 === e3 ? `${a2} - ${t3} ${n3}` : this.small ? `${a2.substring(0, 3)} ${n3} - ${t3.substring(0, 3)} ${e3}` : `${a2} ${n3} - ${t3} ${e3}`;
      }
      t2 = `${this.texts.week} ${e2.getWeek(this.startWeekOnSunday ? e2.addDays(s2, 1) : s2)} (${l2})`;
      break;
    }
    case "day":
      t2 = this.utils.date.formatDate(s2, this.texts.dateFormat, this.texts);
  }
  return t2;
}, viewCells() {
  const e2 = this.utils.date;
  let t2 = [], s2 = null, i2 = false;
  this.watchRealTime || (this.now = new Date());
  const n2 = this.now;
  switch (this.view.id) {
    case "years":
      s2 = this.view.startDate.getFullYear(), t2 = Array.apply(null, Array(25)).map((t3, i3) => {
        const a2 = new Date(s2 + i3, 0, 1), l2 = new Date(s2 + i3 + 1, 0, 1);
        return l2.setSeconds(-1), { startDate: a2, formattedDate: e2.formatDateLite(a2), endDate: l2, content: s2 + i3, current: s2 + i3 === n2.getFullYear() };
      });
      break;
    case "year":
      s2 = this.view.startDate.getFullYear(), t2 = Array.apply(null, Array(12)).map((t3, i3) => {
        const a2 = new Date(s2, i3, 1), l2 = new Date(s2, i3 + 1, 1);
        return l2.setSeconds(-1), { startDate: a2, formattedDate: e2.formatDateLite(a2), endDate: l2, content: this.xsmall ? this.months[i3].label.substr(0, 3) : this.months[i3].label, current: i3 === n2.getMonth() && s2 === n2.getFullYear() };
      });
      break;
    case "month": {
      const s3 = this.view.startDate.getMonth(), n3 = new Date(this.view.firstCellDate);
      i2 = false, t2 = Array.apply(null, Array(42)).map((t3, a2) => {
        const l2 = e2.addDays(n3, a2), r2 = new Date(l2);
        r2.setHours(23, 59, 59, 0);
        const o2 = !i2 && e2.isToday(l2) && !i2++;
        return { startDate: l2, formattedDate: e2.formatDateLite(l2), endDate: r2, content: l2.getDate(), today: o2, outOfScope: l2.getMonth() !== s3, class: `vuecal__cell--day${l2.getDay() || 7}` };
      }), (this.hideWeekends || this.hideWeekdays.length) && (t2 = t2.filter((e3) => {
        const t3 = e3.startDate.getDay() || 7;
        return !(this.hideWeekends && t3 >= 6 || this.hideWeekdays.length && this.hideWeekdays.includes(t3));
      }));
      break;
    }
    case "week": {
      i2 = false;
      const s3 = this.view.startDate, n3 = this.weekDays;
      t2 = n3.map((t3, n4) => {
        const a2 = e2.addDays(s3, n4), l2 = new Date(a2);
        l2.setHours(23, 59, 59, 0);
        const r2 = (a2.getDay() || 7) - 1;
        return { startDate: a2, formattedDate: e2.formatDateLite(a2), endDate: l2, today: !i2 && e2.isToday(a2) && !i2++, specialHours: this.specialDayHours[r2] || [] };
      }).filter((e3, t3) => !n3[t3].hide);
      break;
    }
    case "day": {
      const s3 = this.view.startDate, i3 = new Date(this.view.startDate);
      i3.setHours(23, 59, 59, 0);
      const n3 = (s3.getDay() || 7) - 1;
      t2 = [{ startDate: s3, formattedDate: e2.formatDateLite(s3), endDate: i3, today: e2.isToday(s3), specialHours: this.specialDayHours[n3] || [] }];
      break;
    }
  }
  return t2;
}, visibleDaysCount() {
  return this.isDayView ? 1 : 7 - this.weekDays.reduce((e2, t2) => e2 + t2.hide, 0);
}, cellWidth() {
  return 100 / this.visibleDaysCount;
}, cssClasses() {
  const { resizeAnEvent: e2, dragAnEvent: t2, dragCreateAnEvent: s2 } = this.domEvents;
  return { [`vuecal--${this.view.id}-view`]: true, [`vuecal--${this.locale}`]: this.locale, "vuecal--no-time": !this.time, "vuecal--view-with-time": this.hasTimeColumn, "vuecal--week-numbers": this.showWeekNumbers && this.isMonthView, "vuecal--twelve-hour": this.twelveHour, "vuecal--click-to-navigate": this.clickToNavigate, "vuecal--hide-weekends": this.hideWeekends, "vuecal--split-days": this.hasSplits, "vuecal--sticky-split-labels": this.hasSplits && this.stickySplitLabels, "vuecal--overflow-x": this.minCellWidth && this.isWeekView || this.hasSplits && this.minSplitWidth, "vuecal--small": this.small, "vuecal--xsmall": this.xsmall, "vuecal--resizing-event": e2._eid, "vuecal--drag-creating-event": s2.event, "vuecal--dragging-event": t2._eid, "vuecal--events-on-month-view": this.eventsOnMonthView, "vuecal--short-events": this.isMonthView && "short" === this.eventsOnMonthView, "vuecal--has-touch": "undefined" != typeof window && "ontouchstart" in window };
}, isYearsOrYearView() {
  return ["years", "year"].includes(this.view.id);
}, isYearsView() {
  return "years" === this.view.id;
}, isYearView() {
  return "year" === this.view.id;
}, isMonthView() {
  return "month" === this.view.id;
}, isWeekOrDayView() {
  return ["week", "day"].includes(this.view.id);
}, isWeekView() {
  return "week" === this.view.id;
}, isDayView() {
  return "day" === this.view.id;
} }, watch: { events: { handler(e2, t2) {
  this.updateMutableEvents(e2), this.addEventsToView();
}, deep: true }, locale(e2) {
  this.loadLocale(e2);
}, selectedDate(e2) {
  this.updateSelectedDate(e2);
}, activeView(e2) {
  this.switchView(e2);
} } };
var Ue = z(Pe, [["render", function(w2, D2, g2, f2, k2, M2) {
  const T2 = p("vuecal-header"), E2 = p("all-day-bar"), C2 = p("weekdays-headings"), S2 = p("vuecal-cell");
  return e(), t("div", { class: n(["vuecal__flex vuecal", M2.cssClasses]), column: "", ref: "vuecal", lang: g2.locale }, [l(T2, { options: w2.$props, "edit-events": M2.editEvents, "view-props": { views: M2.views, weekDaysInHeader: M2.weekDaysInHeader }, "week-days": M2.weekDays, "has-splits": M2.hasSplits, "day-splits": M2.daySplits, "switch-to-narrower-view": M2.switchToNarrowerView }, y({ "arrow-prev": o(() => [u(w2.$slots, "arrow-prev", {}, () => [oe, de, ue])]), "arrow-next": o(() => [u(w2.$slots, "arrow-next", {}, () => [he, ce, ve])]), "today-button": o(() => [u(w2.$slots, "today-button", {}, () => [d("span", pe, h(k2.texts.today), 1)])]), title: o(() => [u(w2.$slots, "title", { title: M2.viewTitle, view: k2.view }, () => [v(h(M2.viewTitle), 1)])]), _: 2 }, [w2.$slots["weekday-heading"] ? { name: "weekday-heading", fn: o(({ heading: e2, view: t2 }) => [u(w2.$slots, "weekday-heading", { heading: e2, view: t2 })]) } : void 0, w2.$slots["split-label"] ? { name: "split-label", fn: o(({ split: e2 }) => [u(w2.$slots, "split-label", { split: e2, view: k2.view.id })]) } : void 0]), 1032, ["options", "edit-events", "view-props", "week-days", "has-splits", "day-splits", "switch-to-narrower-view"]), g2.hideBody ? c("", true) : (e(), t("div", me, [l(r, { name: `slide-fade--${k2.transitionDirection}`, appear: g2.transitions }, { default: o(() => [(e(), t("div", { class: "vuecal__flex", style: { "min-width": "100%" }, key: !!g2.transitions && k2.view.id, column: "" }, [g2.showAllDayEvents && M2.hasTimeColumn && (!M2.cellOrSplitMinWidth || M2.isDayView && !g2.minSplitWidth) ? (e(), m(E2, _(b({ key: 0 }, M2.allDayBar)), { event: o(({ event: s2, view: i2 }) => [u(w2.$slots, "event", { view: i2, event: s2 }, () => [M2.editEvents.title && s2.titleEditable ? (e(), t("div", { key: 0, class: "vuecal__event-title vuecal__event-title--edit", contenteditable: "", onBlur: (e2) => M2.onEventTitleBlur(e2, s2), innerHTML: s2.title }, null, 40, we)) : s2.title ? (e(), t("div", { key: 1, class: "vuecal__event-title", innerHTML: s2.title }, null, 8, ye)) : c("", true), !s2.content || M2.hasShortEvents || M2.isShortMonthView ? c("", true) : (e(), t("div", { key: 2, class: "vuecal__event-content", innerHTML: s2.content }, null, 8, De))])]), _: 3 }, 16)) : c("", true), d("div", { class: n(["vuecal__bg", { vuecal__flex: !M2.hasTimeColumn }]), column: "" }, [d("div", ge, [M2.hasTimeColumn ? (e(), t("div", fe, [g2.showAllDayEvents && M2.cellOrSplitMinWidth && (!M2.isDayView || g2.minSplitWidth) ? (e(), t("div", { key: 0, class: "vuecal__all-day-text", style: a({ height: M2.allDayBar.height }) }, [d("span", null, h(k2.texts.allDay), 1)], 4)) : c("", true), (e(true), t(s, null, i(M2.timeCells, (s2, i2) => (e(), t("div", { class: "vuecal__time-cell", key: i2, style: a(`height: ${g2.timeCellHeight}px`) }, [u(w2.$slots, "time-cell", { hours: s2.hours, minutes: s2.minutes }, () => [_e, d("span", be, h(s2.label), 1)])], 4))), 128))])) : c("", true), g2.showWeekNumbers && M2.isMonthView ? (e(), t("div", ke, [(e(), t(s, null, i(6, (e2) => d("div", { class: "vuecal__flex vuecal__week-number-cell", key: e2, grow: "" }, [u(w2.$slots, "week-number-cell", { week: M2.getWeekNumber(e2 - 1) }, () => [v(h(M2.getWeekNumber(e2 - 1)), 1)])])), 64))])) : c("", true), d("div", { class: n(["vuecal__flex vuecal__cells", `${k2.view.id}-view`]), grow: "", wrap: !M2.cellOrSplitMinWidth || !M2.isWeekView, column: !!M2.cellOrSplitMinWidth }, [M2.cellOrSplitMinWidth && M2.isWeekView ? (e(), m(C2, { key: 0, "transition-direction": k2.transitionDirection, "week-days": M2.weekDays, "switch-to-narrower-view": M2.switchToNarrowerView, style: a(M2.cellOrSplitMinWidth ? `min-width: ${M2.cellOrSplitMinWidth}px` : "") }, y({ _: 2 }, [w2.$slots["weekday-heading"] ? { name: "weekday-heading", fn: o(({ heading: e2, view: t2 }) => [u(w2.$slots, "weekday-heading", { heading: e2, view: t2 })]) } : void 0, w2.$slots["split-label"] ? { name: "split-label", fn: o(({ split: e2 }) => [u(w2.$slots, "split-label", { split: e2, view: k2.view.id })]) } : void 0]), 1032, ["transition-direction", "week-days", "switch-to-narrower-view", "style"])) : M2.hasSplits && g2.stickySplitLabels && g2.minSplitWidth ? (e(), t("div", { key: 1, class: "vuecal__flex vuecal__split-days-headers", style: a(M2.cellOrSplitMinWidth ? `min-width: ${M2.cellOrSplitMinWidth}px` : "") }, [(e(true), t(s, null, i(M2.daySplits, (s2, i2) => (e(), t("div", { class: n(["day-split-header", s2.class || false]), key: i2 }, [u(w2.$slots, "split-label", { split: s2, view: k2.view.id }, () => [v(h(s2.label), 1)])], 2))), 128))], 4)) : c("", true), g2.showAllDayEvents && M2.hasTimeColumn && (M2.isWeekView && M2.cellOrSplitMinWidth || M2.isDayView && M2.hasSplits && g2.minSplitWidth) ? (e(), m(E2, _(b({ key: 2 }, M2.allDayBar)), { event: o(({ event: s2, view: i2 }) => [u(w2.$slots, "event", { view: i2, event: s2 }, () => [M2.editEvents.title && s2.titleEditable ? (e(), t("div", { key: 0, class: "vuecal__event-title vuecal__event-title--edit", contenteditable: "", onBlur: (e2) => M2.onEventTitleBlur(e2, s2), innerHTML: s2.title }, null, 40, Te)) : s2.title ? (e(), t("div", { key: 1, class: "vuecal__event-title", innerHTML: s2.title }, null, 8, Ee)) : c("", true), !s2.content || M2.hasShortEvents || M2.isShortMonthView ? c("", true) : (e(), t("div", { key: 2, class: "vuecal__event-content", innerHTML: s2.content }, null, 8, Ce))])]), _: 3 }, 16)) : c("", true), d("div", { class: "vuecal__flex", ref: (e2) => k2.cellsEl = e2, grow: "", wrap: !M2.cellOrSplitMinWidth || !M2.isWeekView, style: a(M2.cellOrSplitMinWidth ? `min-width: ${M2.cellOrSplitMinWidth}px` : "") }, [(e(true), t(s, null, i(M2.viewCells, (s2, i2) => (e(), m(S2, { key: i2, options: w2.$props, "edit-events": M2.editEvents, data: s2, "cell-width": g2.hideWeekdays.length && (M2.isWeekView || M2.isMonthView) && M2.cellWidth, "min-timestamp": M2.minTimestamp, "max-timestamp": M2.maxTimestamp, "cell-splits": M2.hasSplits && M2.daySplits || [] }, { "cell-content": o(({ events: i3, split: n2, selectCell: a2 }) => [u(w2.$slots, "cell-content", { cell: s2, view: k2.view, goNarrower: a2, events: i3 }, () => [n2 && !g2.stickySplitLabels ? (e(), t("div", { key: 0, class: "split-label", innerHTML: n2.label }, null, 8, Oe)) : c("", true), s2.content ? (e(), t("div", { key: 1, class: "vuecal__cell-date", innerHTML: s2.content }, null, 8, $e)) : c("", true), (M2.isMonthView && !g2.eventsOnMonthView || M2.isYearsOrYearView && g2.eventsCountOnYearView) && i3.length ? (e(), t("div", xe, [u(w2.$slots, "events-count", { view: k2.view, events: i3 }, () => [v(h(i3.length), 1)])])) : c("", true), !M2.cellOrSplitHasEvents(i3, n2) && M2.isWeekOrDayView ? (e(), t("div", He, [u(w2.$slots, "no-event", {}, () => [v(h(k2.texts.noEvent), 1)])])) : c("", true)])]), event: o(({ event: i3, view: n2 }) => [u(w2.$slots, "event", { view: n2, event: i3 }, () => [M2.editEvents.title && i3.titleEditable ? (e(), t("div", { key: 0, class: "vuecal__event-title vuecal__event-title--edit", contenteditable: "", onBlur: (e2) => M2.onEventTitleBlur(e2, i3), innerHTML: i3.title }, null, 40, We)) : i3.title ? (e(), t("div", { key: 1, class: "vuecal__event-title", innerHTML: i3.title }, null, 8, je)) : c("", true), !g2.time || i3.allDay || M2.isMonthView && (i3.allDay || "short" === g2.showAllDayEvents) || M2.isShortMonthView ? c("", true) : (e(), t("div", Ae, [v(h(k2.utils.date.formatTime(i3.start, M2.TimeFormat)), 1), i3.endTimeMinutes ? (e(), t("span", Ve, "\xA0- " + h(k2.utils.date.formatTime(i3.end, M2.TimeFormat, null, true)), 1)) : c("", true), i3.daysCount > 1 && (i3.segments[s2.formattedDate] || {}).isFirstDay ? (e(), t("small", Ye, "\xA0+" + h(i3.daysCount - 1) + h((k2.texts.day[0] || "").toLowerCase()), 1)) : c("", true)])), !i3.content || M2.isMonthView && i3.allDay && "short" === g2.showAllDayEvents || M2.isShortMonthView ? c("", true) : (e(), t("div", { key: 3, class: "vuecal__event-content", innerHTML: i3.content }, null, 8, Le))])]), "no-event": o(() => [u(w2.$slots, "no-event", {}, () => [v(h(k2.texts.noEvent), 1)])]), _: 2 }, 1032, ["options", "edit-events", "data", "cell-width", "min-timestamp", "max-timestamp", "cell-splits"]))), 128))], 12, Se)], 10, Me)])], 2)]))]), _: 3 }, 8, ["name", "appear"]), k2.ready ? c("", true) : (e(), t("div", Fe, Be))]))], 10, re);
}]]);
export { Ue as default };
