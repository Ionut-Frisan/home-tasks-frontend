import "./chunk-RSJERJUL.js";

// node_modules/vue-cal/dist/drag-and-drop.es.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var e = null;
var t = null;
var l = { id: null, date: null };
var i = false;
var a = true;
var n = { el: null, cell: null, timeout: null };
var r = { _eid: null, fromVueCal: null, toVueCal: null };
var u = class {
  constructor(e2) {
    __publicField(this, "_vuecal");
    this._vuecal = e2;
  }
  _getEventStart(e2) {
    const { timeStep: t2, timeCellHeight: l2, timeFrom: i2, utils: a2 } = this._vuecal;
    let { y: n2 } = a2.cell.getPosition(e2);
    return n2 -= 1 * e2.dataTransfer.getData("cursor-grab-at"), Math.round(n2 * t2 / parseInt(l2) + i2);
  }
  _updateEventStartEnd(e2, t2, l2, i2) {
    const a2 = 1 * l2.duration || t2.endTimeMinutes - t2.startTimeMinutes;
    let n2 = Math.max(this._getEventStart(e2), 0);
    if (this._vuecal.snapToTime) {
      const e3 = n2 + this._vuecal.snapToTime / 2;
      n2 = e3 - e3 % this._vuecal.snapToTime;
    }
    t2.startTimeMinutes = n2, t2.start = new Date(new Date(i2).setMinutes(n2)), t2.endTimeMinutes = Math.min(n2 + a2, 1440), t2.end = new Date(new Date(i2).setMinutes(t2.endTimeMinutes));
  }
  eventDragStart(e2, t2) {
    if (3 === e2.target.nodeType)
      return e2.preventDefault();
    e2.dataTransfer.dropEffect = "move", e2.dataTransfer.setData("event", JSON.stringify(t2)), e2.dataTransfer.setData("cursor-grab-at", e2.offsetY);
    const { clickHoldAnEvent: n2 } = this._vuecal.domEvents;
    setTimeout(() => {
      n2._eid = null, clearTimeout(n2.timeoutId), t2.deleting = false;
    }, 0), this._vuecal.domEvents.dragAnEvent._eid = t2._eid, r._eid = t2._eid, r.fromVueCal = this._vuecal._.uid, t2.dragging = true, setTimeout(() => t2.draggingStatic = true, 0), i = false, l = { id: this._vuecal.view.id, date: this._vuecal.view.startDate }, a = true;
  }
  eventDragEnd(e2) {
    this._vuecal.domEvents.dragAnEvent._eid = null, r._eid = null, e2.dragging = false, e2.draggingStatic = false;
    const { fromVueCal: t2, toVueCal: n2 } = r;
    n2 && t2 !== n2 && this._vuecal.utils.event.deleteAnEvent(e2), r.fromVueCal = null, r.toVueCal = null, i && a && l.id && this._vuecal.switchView(l.id, l.date, true);
  }
  cellDragEnter(e2, t2, l2) {
    const i2 = e2.currentTarget;
    if (!e2.currentTarget.contains(e2.relatedTarget)) {
      if (i2 === n.el || !i2.className.includes("vuecal__cell-content"))
        return false;
      n.el && (n.cell.highlighted = false), n = { el: i2, cell: t2, timeout: clearTimeout(n.timeout) }, t2.highlighted = true, ["years", "year", "month"].includes(this._vuecal.view.id) && (n.timeout = setTimeout(() => this._vuecal.switchToNarrowerView(l2), 2e3));
    }
  }
  cellDragOver(e2, t2, l2, i2) {
    e2.preventDefault(), t2.highlighted = true, (i2 || 0 === i2) && (t2.highlightedSplit = i2);
  }
  cellDragLeave(e2, t2) {
    e2.preventDefault(), e2.currentTarget.contains(e2.relatedTarget) || (t2.highlightedSplit = false, n.cell === t2 && (clearTimeout(n.timeout), n = { el: null, cell: null, timeout: null }, t2.highlighted = false));
  }
  cellDragDrop(e2, t2, l2, i2) {
    e2.preventDefault(), clearTimeout(n.timeout), n = { el: null, cell: null, timeout: null };
    const u2 = JSON.parse(e2.dataTransfer.getData("event") || "{}");
    let s, c;
    if (r.fromVueCal !== this._vuecal._.uid) {
      const { _eid: e3, start: t3, end: a2, duration: n2, ...r2 } = u2;
      s = this._vuecal.utils.event.createAnEvent(l2, n2, { ...r2, split: i2 });
    } else if (s = this._vuecal.view.events.find((e3) => e3._eid === r._eid), s || (s = this._vuecal.mutableEvents.find((e3) => e3._eid === r._eid), c = !!s), !s) {
      const e3 = u2.endTimeMinutes - u2.startTimeMinutes, { start: t3, end: a2, ...n2 } = u2;
      s = this._vuecal.utils.event.createAnEvent(l2, e3, { ...n2, split: i2 });
    }
    const { start: d, split: o } = s;
    this._updateEventStartEnd(e2, s, u2, l2), c && this._vuecal.addEventsToView([s]), s.dragging = false, (i2 || 0 === i2) && (s.split = i2), t2.highlighted = false, t2.highlightedSplit = null, a = false, r.toVueCal = this._vuecal._.uid;
    const v = { event: this._vuecal.cleanupEvent(s), oldDate: d, newDate: s.start, ...(i2 || 0 === i2) && { oldSplit: o, newSplit: i2 }, originalEvent: this._vuecal.cleanupEvent(u2), external: !r.fromVueCal };
    this._vuecal.$emit("event-drop", v), this._vuecal.$emit("event-change", { event: v.event, originalEvent: v.originalEvent }), setTimeout(() => {
      r._eid && this.eventDragEnd(s);
    }, 300);
  }
  viewSelectorDragEnter(l2, a2, n2) {
    l2.currentTarget.contains(l2.relatedTarget) || (n2.highlightedControl = a2, clearTimeout(e), e = setTimeout(() => {
      if (["previous", "next"].includes(a2))
        this._vuecal[a2](), clearInterval(t), t = setInterval(this._vuecal[a2], 800);
      else if ("today" === a2) {
        let e2;
        clearInterval(t), this._vuecal.view.id.includes("year") && (e2 = this._vuecal.enabledViews.filter((e3) => !e3.includes("year"))[0]), this._vuecal.switchView(e2 || this._vuecal.view.id, new Date(new Date().setHours(0, 0, 0, 0)), true);
      } else
        this._vuecal.switchView(a2, null, true);
      i = true;
    }, 800));
  }
  viewSelectorDragLeave(l2, i2, a2) {
    l2.currentTarget.contains(l2.relatedTarget) || a2.highlightedControl === i2 && (a2.highlightedControl = null, e && (e = clearTimeout(e)), t && (t = clearInterval(t)));
  }
};
export {
  u as DragAndDrop
};
/**
  * vue-cal v4.3.4
  * (c) 2022 Antoni Andre <antoniandre.web@gmail.com>
  * @license MIT
  */
//# sourceMappingURL=drag-and-drop.es-VTKP5RVD.js.map
